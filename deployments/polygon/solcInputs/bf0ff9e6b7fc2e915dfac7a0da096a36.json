{
  "language": "Solidity",
  "sources": {
    "src/contracts/EligibilityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./interfaces/IEligibility.sol\";\nimport \"./interfaces/IEligibilityManager.sol\";\n\ncontract EligibilityManager is IEligibilityManager, OwnableUpgradeable {\n    EligibilityModule[] public override modules;\n\n    function __EligibilityManager_init() external override initializer {\n        __Ownable_init();\n    }\n\n    function addModule(address implementation) external override onlyOwner {\n        if (implementation == address(0)) revert NoImplementation();\n\n        IEligibility elig = IEligibility(implementation);\n        string memory name = elig.name();\n        EligibilityModule memory module = EligibilityModule(\n            implementation,\n            elig.targetAsset(),\n            name\n        );\n        modules.push(module);\n        emit ModuleAdded(\n            implementation,\n            module.targetAsset,\n            name,\n            elig.finalized()\n        );\n    }\n\n    function allModules() external view override returns (EligibilityModule[] memory) {\n        return modules;\n    }\n\n    function allModuleNames() external view override returns (string[] memory) {\n        EligibilityModule[] memory modulesCopy = modules;\n        string[] memory names = new string[](modulesCopy.length);\n        for (uint256 i = 0; i < modulesCopy.length; i++) {\n            names[i] = modulesCopy[i].name;\n        }\n        return names;\n    }\n\n    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n        external\n        virtual\n        override\n        returns (address)\n    {\n        if (moduleIndex >= modules.length) revert OutOfBounds();\n        address eligImpl = modules[moduleIndex].implementation;\n        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n        IEligibility(eligibilityClone).__Eligibility_init_bytes(\n            configData\n        );\n        return eligibilityClone;\n    }\n\n    function updateModule(uint256 moduleIndex, address implementation) external override onlyOwner {\n        if (moduleIndex >= modules.length) revert OutOfBounds();\n        if (implementation == address(0)) revert NoImplementation();\n        modules[moduleIndex].implementation = implementation;\n        IEligibility elig = IEligibility(implementation);\n        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "src/contracts/interfaces/IEligibility.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IEligibility {\n    // Read functions.\n    function name() external pure returns (string memory);\n\n    function finalized() external view returns (bool);\n\n    function targetAsset() external pure returns (address);\n\n    function checkAllEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkEligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool[] memory);\n\n    function checkAllIneligible(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\n\n    // Write functions.\n    function __Eligibility_init_bytes(bytes calldata configData) external;\n\n    function beforeMintHook(uint256[] calldata tokenIds) external;\n\n    function afterMintHook(uint256[] calldata tokenIds) external;\n\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\n}\n"
    },
    "src/contracts/interfaces/IEligibilityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IEligibilityManager {\n    struct EligibilityModule {\n        address implementation;\n        address targetAsset;\n        string name;\n    }\n\n    function modules(uint256) external view returns(address, address, string memory);\n\n    function __EligibilityManager_init() external;\n\n    function addModule(address implementation) external;\n\n    function updateModule(uint256 moduleIndex, address implementation) external;\n\n    function deployEligibility(uint256 vaultId, bytes calldata initData) external returns (address);\n\n    function allModules() external view returns (EligibilityModule[] memory);\n\n    function allModuleNames() external view returns (string[] memory);\n\n    event ModuleAdded(\n        address implementation,\n        address targetAsset,\n        string name,\n        bool finalizedOnDeploy\n    );\n    event ModuleUpdated(\n        address implementation,\n        string name,\n        bool finalizedOnDeploy\n    );\n\n    error NoImplementation();\n    error OutOfBounds();\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/FNFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./interfaces/IEligibility.sol\";\nimport \"./interfaces/IEligibilityManager.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/IFNFTCollection.sol\";\nimport \"./interfaces/IFNFTCollectionFactory.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract FNFTCollection is\n    IFNFTCollection,\n    OwnableUpgradeable,\n    IERC165,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 public constant BASE = 10**18;\n\n    mapping(uint256 => uint256) public override quantity1155;\n    EnumerableSetUpgradeable.UintSet internal holdings;\n\n    IEligibility public override eligibilityStorage;\n    IFNFTCollectionFactory public override factory;\n    IVaultManager public override vaultManager;\n    address public override curator;\n\n    uint256 public override vaultId;\n    uint256 private randNonce;\n\n    /// @notice the length of auctions\n    uint256 public override auctionLength;\n\n    address public override assetAddress;\n    bool public override is1155;\n    bool public override allowAllItems;\n    bool public override enableMint;\n    bool public override enableRandomRedeem;\n    bool public override enableTargetRedeem;\n    bool public override enableRandomSwap;\n    bool public override enableTargetSwap;\n    bool public override enableBid;\n\n    /// @notice only used for ERC-721 tokens\n    mapping (uint256 => address) public depositors;\n    mapping (uint256 => Auction) public auctions;\n\n    function __FNFTCollection_init(\n        string memory _name,\n        string memory _symbol,\n        address _curator,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external override virtual initializer {\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n        if (_assetAddress == address(0)) revert ZeroAddress();\n        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/, false /*enableBid*/);\n        IFNFTCollectionFactory _factory = IFNFTCollectionFactory(msg.sender);\n        vaultManager = IVaultManager(_factory.vaultManager());\n        assetAddress = _assetAddress;\n        curator = _curator;\n        factory = _factory;\n        vaultId = vaultManager.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        auctionLength = 3 days;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n    }\n\n    function allHoldings() external view override virtual returns (uint256[] memory) {\n        uint256 len = holdings.length();\n        uint256[] memory idArray = new uint256[](len);\n        for (uint256 i; i < len;) {\n            idArray[i] = holdings.at(i);\n            unchecked {\n                ++i;\n            }\n        }\n        return idArray;\n    }\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external override virtual returns (address) {\n        _onlyPrivileged();\n        if (address(eligibilityStorage) != address(0)) revert EligibilityAlreadySet();\n        IEligibilityManager eligManager = IEligibilityManager(\n            factory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        eligibilityStorage = IEligibility(_eligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(moduleIndex, _eligibility);\n        return _eligibility;\n    }\n\n    function finalizeVault() external override virtual {\n        setCurator(address(0));\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external override virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {\n        return holdings.at(holdingsIndex);\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        override\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function withdraw(uint256[] calldata tokenIds) external override virtual returns (uint256[] memory) {\n        _onlyOwnerIfPaused(2);\n        if (!enableBid) revert BidDisabled();\n\n        uint256 amount = tokenIds.length;\n\n        for (uint256 i; i < amount;) {\n            uint256 tokenId = tokenIds[i];\n            if (depositors[tokenId] != msg.sender) revert NotNFTOwner();\n            unchecked {\n                ++i;\n            }\n        }\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, BASE * amount);\n\n        // Pay the tokens + toll.\n        (,, uint256 _targetRedeemFee,,) = vaultFees();\n        uint256 totalFee = _targetRedeemFee * amount;\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = _withdrawNFTsTo(amount, tokenIds, msg.sender);\n        emit Redeemed(redeemedIds, tokenIds, msg.sender);\n        return redeemedIds;\n    }\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external override virtual {\n        _onlyPrivileged();\n        _setMetadata(name_, symbol_);\n    }\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external override virtual returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function totalHoldings() external view override virtual returns (uint256) {\n        return holdings.length();\n    }\n\n    function version() external pure override returns (string memory) {\n        return \"v1.0.0\";\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        override\n        virtual\n        returns (bool)\n    {\n        if (allowAllItems) {\n            return true;\n        }\n\n        IEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    function retrieveTokens(uint256 amount, address from, address to) public onlyOwner {\n        _burn(from, amount);\n        _mint(to, amount);\n    }\n\n    function disableVaultFees() public override virtual {\n        _onlyPrivileged();\n        factory.disableVaultFees(vaultId);\n    }\n\n    function flashFee(address borrowedToken, uint256 amount) public view override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTCollection\n    ) returns (uint256) {\n        if (borrowedToken != address(this)) revert InvalidToken();\n        return factory.flashLoanFee() * amount / 10000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override (\n        IERC3156FlashLenderUpgradeable,\n        IFNFTCollection\n    ) returns (bool) {\n        _onlyOwnerIfPaused(5);\n\n        uint256 flashLoanFee = vaultManager.excludedFromFees(address(receiver)) ? 0 : flashFee(borrowedToken, amount);\n        return _flashLoan(receiver, borrowedToken, amount, flashLoanFee, data);\n    }\n\n    function mintFee() public view override virtual returns (uint256) {\n        (uint256 _mintFee, , , ,) = factory.vaultFees(vaultId);\n        return _mintFee;\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public override virtual nonReentrant returns (uint256) {\n        _onlyOwnerIfPaused(1);\n        if (!enableMint) revert MintDisabled();\n        // Take the NFTs.\n        uint256 count = _receiveNFTs(tokenIds, amounts);\n\n        // Mint to the user.\n        _mint(to, BASE * count);\n        uint256 totalFee = mintFee() * count;\n        _chargeAndDistributeFees(to, totalFee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function randomRedeemFee() public view override virtual returns (uint256) {\n        (, uint256 _randomRedeemFee, , ,) = factory.vaultFees(vaultId);\n        return _randomRedeemFee;\n    }\n\n    function randomSwapFee() public view override virtual returns (uint256) {\n        (, , , uint256 _randomSwapFee, ) = factory.vaultFees(vaultId);\n        return _randomSwapFee;\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        override\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        _onlyOwnerIfPaused(2);\n        if (enableBid) revert BidEnabled();\n        if (amount != specificIds.length && !enableRandomRedeem) revert RandomRedeemDisabled();\n        if (specificIds.length != 0 && !enableTargetRedeem) revert TargetRedeemDisabled();\n\n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, BASE * amount);\n\n        // Pay the tokens + toll.\n        (, uint256 _randomRedeemFee, uint256 _targetRedeemFee, ,) = vaultFees();\n        uint256 totalFee = (_targetRedeemFee * specificIds.length) + (\n            _randomRedeemFee * (amount - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = _withdrawNFTsTo(amount, specificIds, to);\n        emit Redeemed(redeemedIds, specificIds, to);\n        return redeemedIds;\n    }\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public override virtual {\n        _onlyPrivileged();\n        factory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    // The curator has control over options like fees and features\n    function setCurator(address _curator) public override virtual {\n        _onlyPrivileged();\n        if (curator == _curator) revert SameCurator();\n        emit CuratorUpdated(curator, _curator);\n        curator = _curator;\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap,\n        bool _enableBid\n    ) public override virtual {\n        _onlyPrivileged();\n        enableMint = _enableMint;\n        enableRandomRedeem = _enableRandomRedeem;\n        enableTargetRedeem = _enableTargetRedeem;\n        enableRandomSwap = _enableRandomSwap;\n        enableTargetSwap = _enableTargetSwap;\n        enableBid = _enableBid;\n\n        emit VaultFeaturesUpdated(\n            _enableMint,\n            _enableRandomRedeem,\n            _enableTargetRedeem,\n            _enableRandomSwap,\n            _enableTargetSwap,\n            _enableBid\n        );\n    }\n\n    /// @notice allow curator to update the auction length\n    /// @param _auctionLength the new base price\n    function setAuctionLength(uint256 _auctionLength) external override {\n        _onlyPrivileged();\n        if (\n            _auctionLength < factory.minAuctionLength() || _auctionLength > factory.maxAuctionLength()\n        ) revert InvalidAuctionLength();\n\n        auctionLength = _auctionLength;\n        emit AuctionLengthUpdated(_auctionLength);\n    }\n\n    function shutdown(address recipient) public override onlyOwner {\n        uint256 numItems = totalSupply() / BASE;\n        if (numItems >= 4) revert TooManyNFTs();\n        uint256[] memory specificIds = new uint256[](0);\n        _withdrawNFTsTo(numItems, specificIds, recipient);\n        emit VaultShutdown(assetAddress, numItems, recipient);\n        assetAddress = address(0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC1155ReceiverUpgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IFNFTCollection).interfaceId ||\n                interfaceId == type(IERC165).interfaceId ||\n                super.supportsInterface(interfaceId);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public override virtual nonReentrant returns (uint256[] memory) {\n        _onlyOwnerIfPaused(3);\n        if (enableBid) revert BidEnabled();\n\n        uint256 count;\n        if (is1155) {\n            for (uint256 i; i < tokenIds.length;) {\n                uint256 amount = amounts[i];\n                if (amount == 0) revert ZeroTransferAmount();\n                count += amount;\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            count = tokenIds.length;\n        }\n\n        if (count != specificIds.length && !enableRandomSwap) revert RandomSwapDisabled();\n        if (specificIds.length != 0 && !enableTargetSwap) revert TargetSwapDisabled();\n\n        (, , ,uint256 _randomSwapFee, uint256 _targetSwapFee) = vaultFees();\n        uint256 totalFee = (_targetSwapFee * specificIds.length) + (\n            _randomSwapFee * (count - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Give the NFTs first, so the user wont get the same thing back, just to be nice.\n        uint256[] memory ids = _withdrawNFTsTo(count, specificIds, to);\n\n        _receiveNFTs(tokenIds, amounts);\n\n        emit Swapped(tokenIds, amounts, specificIds, ids, to);\n        return ids;\n    }\n\n    function startAuction(uint256 tokenId, uint256 price) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Inactive) revert AuctionLive();\n        if (price < BASE) revert BidTooLow();\n\n        _burn(msg.sender, price);\n\n        auctions[tokenId] = Auction({\n            livePrice: price,\n            end: block.timestamp + auctionLength,\n            state: AuctionState.Live,\n            winning: msg.sender\n        });\n\n        emit AuctionStarted(msg.sender, tokenId, price);\n    }\n\n    function bid(uint256 tokenId, uint256 price) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Live) revert AuctionNotLive();\n        uint256 livePrice = auctions[tokenId].livePrice;\n        uint256 increase = factory.minBidIncrease() + 10000;\n        if (price * 10000 < livePrice * increase) revert BidTooLow();\n\n        uint256 auctionEnd = auctions[tokenId].end;\n        if (block.timestamp >= auctionEnd) revert AuctionEnded();\n\n        _burn(msg.sender, price);\n        _mint(auctions[tokenId].winning, livePrice);\n\n        auctions[tokenId].livePrice = price;\n        auctions[tokenId].winning = msg.sender;\n\n        if (auctionEnd - block.timestamp <= 15 minutes) {\n            auctions[tokenId].end += 15 minutes;\n        }\n\n        emit BidMade(msg.sender, tokenId, price);\n    }\n\n    function endAuction(uint256 tokenId) external override {\n        _onlyOwnerIfPaused(4);\n        if (!enableBid || is1155) revert BidDisabled();\n        if (auctions[tokenId].state != AuctionState.Live) revert AuctionNotLive();\n        if (block.timestamp < auctions[tokenId].end) revert AuctionNotEnded();\n\n        address winner = auctions[tokenId].winning;\n        uint256 price = auctions[tokenId].livePrice;\n\n        auctions[tokenId].livePrice = 0;\n        auctions[tokenId].end = 0;\n        auctions[tokenId].state = AuctionState.Inactive;\n        auctions[tokenId].winning = address(0);\n\n        uint256 premium = price - BASE;\n        if (premium > 0) _mint(depositors[tokenId], premium);\n\n        uint256[] memory withdrawTokenIds = new uint256[](1);\n        withdrawTokenIds[0] = tokenId;\n        _withdrawNFTsTo(1, withdrawTokenIds, winner);\n\n        emit AuctionWon(winner, tokenId, price);\n    }\n\n    function getAuction(uint256 tokenId) external view override returns (uint256, uint256, AuctionState, address) {\n        AuctionState state = auctions[tokenId].state;\n        if (state == AuctionState.Inactive) revert AuctionNotLive();\n\n        return (\n            auctions[tokenId].livePrice,\n            auctions[tokenId].end,\n            state,\n            auctions[tokenId].winning\n        );\n    }\n\n    function getDepositor(uint256 tokenId) external view override returns (address depositor) {\n        depositor = depositors[tokenId];\n        if (depositor == address(0)) revert NotInVault();\n    }\n\n    function targetRedeemFee() public view override virtual returns (uint256) {\n        (, , uint256 _targetRedeemFee, ,) = factory.vaultFees(vaultId);\n        return _targetRedeemFee;\n    }\n\n    function targetSwapFee() public view override virtual returns (uint256) {\n        (, , , ,uint256 _targetSwapFee) = factory.vaultFees(vaultId);\n        return _targetSwapFee;\n    }\n\n    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {\n        return factory.vaultFees(vaultId);\n    }\n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function _afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        IEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal override virtual {\n        if (amount == 0) {\n            return;\n        }\n\n        IVaultManager _vaultManager = vaultManager;\n\n        if (_vaultManager.excludedFromFees(msg.sender)) {\n            return;\n        }\n\n        // Mint fees directly to the distributor and distribute.\n        address feeDistributor = _vaultManager.feeDistributor();\n        // Changed to a _transfer() in v1.0.3.\n        super._transfer(user, feeDistributor, amount);\n        IFeeDistributor(feeDistributor).distribute(vaultId);\n    }\n\n    function _getRandomTokenIdFromVault() internal virtual returns (uint256) {\n        uint256 randomIndex = uint256(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1),\n                    randNonce,\n                    block.coinbase,\n                    block.difficulty,\n                    block.timestamp\n                )\n            )\n        ) % holdings.length();\n        ++randNonce;\n        return holdings.at(randomIndex);\n    }\n\n    function _receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        if (!allValidNFTs(tokenIds)) revert IneligibleNFTs();\n        uint256 length = tokenIds.length;\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i; i < length;) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                if (amount == 0) revert ZeroTransferAmount();\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] += amount;\n                count += amount;\n                unchecked {\n                    ++i;\n                }\n            }\n            return count;\n        } else {\n            address _assetAddress = assetAddress;\n            for (uint256 i; i < length;) {\n                uint256 tokenId = tokenIds[i];\n                // We may already own the NFT here so we check in order:\n                // Does the vault own it?\n                //   - If so, check if its in holdings list\n                //      - If so, we reject. This means the NFT has already been claimed for.\n                //      - If not, it means we have not yet accounted for this NFT, so we continue.\n                //   -If not, we \"pull\" it from the msg.sender and add to holdings.\n                _transferFromERC721(_assetAddress, tokenId);\n                depositors[tokenId] = msg.sender;\n                holdings.add(tokenId);\n                unchecked {\n                    ++i;\n                }\n            }\n            return length;\n        }\n    }\n\n    function _onlyOwnerIfPaused(uint256 lockId) internal view {\n        if (msg.sender != owner() && IPausable(address(factory)).isPaused(lockId)) revert Paused();\n    }\n\n\n    function _onlyPrivileged() internal view {\n        if (curator == address(0)) {\n            if (msg.sender != owner()) revert NotOwner();\n        } else {\n            if (msg.sender != curator) revert NotCurator();\n        }\n    }\n\n    function _transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Changed in v1.0.4.\n            data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", to, tokenId);\n        } else {\n            // Default.\n            data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", address(this), to, tokenId);\n        }\n        (bool success, bytes memory returnData) = address(assetAddr).call(data);\n        require(success, string(returnData));\n    }\n\n    function _transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Cryptokitties.\n            data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            // Fix here for frontrun attack. Added in v1.0.2.\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n            (address nftOwner) = abi.decode(result, (address));\n            if (!checkSuccess || nftOwner != msg.sender) revert NotNFTOwner();\n            data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n        } else {\n            // Default.\n            // Allow other contracts to \"push\" into the vault, safely.\n            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.\n            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {\n                if (holdings.contains(tokenId)) revert NFTAlreadyInCollection();\n                return;\n            } else {\n                data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n            }\n        }\n        (bool success, bytes memory resultData) = address(assetAddr).call(data);\n        require(success, string(resultData));\n    }\n\n    function _withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n        uint256 specificLength = specificIds.length;\n        for (uint256 i; i < amount;) {\n            // This will always be fine considering the validations made above.\n            uint256 tokenId = i < specificLength ?\n                specificIds[i] : _getRandomTokenIdFromVault();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                quantity1155[tokenId] -= 1;\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n            } else {\n                holdings.remove(tokenId);\n                delete depositors[tokenId];\n                _transferERC721(_assetAddress, to, tokenId);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        _afterRedeemHook(redeemedIds);\n        return redeemedIds;\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrowerUpgradeable {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./ILPStaking.sol\";\nimport \"./IFNFTStaking.sol\";\n\ninterface IFeeDistributor {\n\n  struct FeeReceiver {\n    uint256 allocPoint;\n    address receiver;\n    bool isContract;\n  }\n\n  function distributionPaused() external returns (bool);\n\n  function vaultManager() external returns (IVaultManager);\n\n  function lpStaking() external returns (ILPStaking);\n\n  function fnftStaking() external returns (IFNFTStaking);\n\n  function treasury() external returns (address);\n\n  function allocTotal() external returns (uint256);\n\n  function feeReceivers(uint256) external returns (uint256, address, bool);\n\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external;\n\n  function rescueTokens(address token) external;\n\n  function distribute(uint256 vaultId) external;\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external;\n\n  function initializeVaultReceivers(uint256 _vaultId) external;\n\n  function changeReceiverAlloc(uint256 _idx, uint256 _allocPoint) external;\n\n  function changeReceiverAddress(uint256 _idx, address _address, bool _isContract) external;\n\n  function removeReceiver(uint256 _receiverIdx) external;\n\n  function setTreasuryAddress(address _treasury) external;\n\n  function setLPStakingAddress(address _lpStaking) external;\n\n  function setFNFTStakingAddress(address _inventoryStaking) external;\n\n  function pauseFeeDistribution(bool _pause) external;\n\n  event TreasuryAddressUpdated(address newTreasury);\n  event LPStakingAddressUpdated(address newLPStaking);\n  event FNFTStakingAddressUpdated(address newFNFTStaking);\n  event DistributionPaused(bool paused);\n  event FeeReceiverAdded(address receiver, uint256 allocPoint);\n  event FeeReceiverAllocUpdated(address receiver, uint256 allocPoint);\n  event FeeReceiverAddressUpdated(address oldReceiver, address newReceiver);\n  event FeeReceiverRemoved(address receiver);\n\n  error NotVaultManager();\n  error OutOfBounds();\n  error ZeroAddress();\n}"
    },
    "src/contracts/interfaces/IFNFTCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\n\nimport \"./IEligibility.sol\";\nimport \"./IFNFTCollectionFactory.sol\";\nimport \"./IVaultManager.sol\";\nimport \"../token/ERC20Upgradeable.sol\";\n\ninterface IFNFTCollection is IERC20Upgradeable {\n    enum AuctionState { Inactive, Live, Ended }\n\n    struct Auction {\n        uint256 livePrice;\n        uint256 end;\n        AuctionState state;\n        address winning;\n    }\n\n    function vaultManager() external view returns (IVaultManager);\n\n    function curator() external view returns (address);\n\n    function assetAddress() external view returns (address);\n\n    function factory() external view returns (IFNFTCollectionFactory);\n\n    function eligibilityStorage() external view returns (IEligibility);\n\n    function is1155() external view returns (bool);\n\n    function allowAllItems() external view returns (bool);\n\n    function enableMint() external view returns (bool);\n\n    function enableRandomRedeem() external view returns (bool);\n\n    function enableTargetRedeem() external view returns (bool);\n\n    function enableRandomSwap() external view returns (bool);\n\n    function enableTargetSwap() external view returns (bool);\n\n    function enableBid() external view returns (bool);\n\n    function auctionLength() external view returns (uint256);\n\n    function quantity1155(uint256) external view returns (uint256);\n\n    function vaultId() external view returns (uint256);\n\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\n\n    function allHoldings() external view returns (uint256[] memory);\n\n    function totalHoldings() external view returns (uint256);\n\n    function mintFee() external view returns (uint256);\n\n    function randomRedeemFee() external view returns (uint256);\n\n    function targetRedeemFee() external view returns (uint256);\n\n    function randomSwapFee() external view returns (uint256);\n\n    function targetSwapFee() external view returns (uint256);\n\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function shutdown(address recipient) external;\n\n    function version() external returns (string memory);\n\n    function __FNFTCollection_init(\n        string calldata _name,\n        string calldata _symbol,\n        address _curator,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) external;\n\n    function finalizeVault() external;\n\n    function setVaultMetadata(\n        string calldata name_,\n        string calldata symbol_\n    ) external;\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap,\n        bool _enableBid\n    ) external;\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) external;\n\n    function setAuctionLength(uint256 _auctionLength) external;\n\n    function disableVaultFees() external;\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external returns (address);\n\n    // The curator has control over options like fees and features\n    function setCurator(address _curator) external;\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external returns (uint256);\n\n    function mintTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        address to\n    ) external returns (uint256);\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        returns (uint256[] calldata);\n\n    function redeemTo(\n        uint256 amount,\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n\n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external returns (uint256[] calldata);\n\n    function swapTo(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds,\n        address to\n    ) external returns (uint256[] calldata);\n    function withdraw(uint256[] calldata tokenIds) external returns (uint256[] memory);\n\n    function startAuction(uint256 tokenId, uint256 price) external;\n    function bid(uint256 tokenId, uint256 price) external;\n    function endAuction(uint256 tokenId) external;\n\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address borrowedToken,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    function allValidNFTs(uint256[] calldata tokenIds)\n        external\n        view\n        returns (bool);\n\n    function getAuction(uint256 tokenId) external view returns (uint256, uint256, AuctionState, address);\n    function getDepositor(uint256 tokenId) external view returns (address);\n\n    // /// @notice An event emitted when someone redeems all tokens for the NFT\n    // event TokenRedeemed(address indexed redeemer);\n\n    event AuctionLengthUpdated(uint256 length);\n    /// @notice An event emitted when an auction starts\n    event AuctionStarted(address indexed buyer, uint256 tokenId, uint256 price);\n    /// @notice An event emitted when an auction is won\n    event AuctionWon(address indexed buyer, uint256 tokenId, uint256 price);\n    /// @notice An event emitted when a bid is made\n    event BidMade(address indexed buyer, uint256 tokenId, uint256 price);\n    event CuratorUpdated(address oldCurator, address newCurator);\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\n    event Swapped(\n        uint256[] nftIds,\n        uint256[] amounts,\n        uint256[] specificIds,\n        uint256[] redeemedIds,\n        address to\n    );\n    event VaultInit(\n        uint256 indexed vaultId,\n        address assetAddress,\n        bool is1155,\n        bool allowAllItems\n    );\n    event VaultFeaturesUpdated(\n      bool enableMint,\n      bool enableRandomRedeem,\n      bool enableTargetRedeem,\n      bool enableRandomSwap,\n      bool enableTargetSwap,\n      bool enableBid\n    );\n    event VaultShutdown(address assetAddress, uint256 numItems, address recipient);\n\n    error AuctionEnded();\n    error AuctionLive();\n    error AuctionNotEnded();\n    error AuctionNotLive();\n    error BidDisabled();\n    error BidEnabled();\n    error BidTooLow();\n    error EligibilityAlreadySet();\n    error FeeTooHigh();\n    error IneligibleNFTs();\n    error InvalidAuctionLength();\n    error MintDisabled();\n    error NFTAlreadyInCollection();\n    error NotCurator();\n    error NotNFTOwner();\n    error NotInVault();\n    error NotOwner();\n    error Paused();\n    error RandomRedeemDisabled();\n    error RandomSwapDisabled();\n    error TargetRedeemDisabled();\n    error TargetSwapDisabled();\n    error TooManyNFTs();\n    error InvalidToken();\n    error SameCurator();\n    error ZeroAddress();\n    error ZeroTransferAmount();\n}"
    },
    "src/contracts/interfaces/IFNFTCollectionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../proxy/IBeacon.sol\";\nimport \"./IVaultManager.sol\";\n\ninterface IFNFTCollectionFactory is IBeacon {\n  struct VaultFees {\n      bool active;\n      uint64 mintFee;\n      uint64 randomRedeemFee;\n      uint64 targetRedeemFee;\n      uint64 randomSwapFee;\n      uint64 targetSwapFee;\n  }\n\n  // Read functions.\n  function vaultManager() external view returns (IVaultManager);\n\n  function eligibilityManager() external view returns (address);\n\n  function factoryMintFee() external view returns (uint64);\n\n  function factoryRandomRedeemFee() external view returns (uint64);\n\n  function factoryTargetRedeemFee() external view returns (uint64);\n\n  function factoryRandomSwapFee() external view returns (uint64);\n\n  function factoryTargetSwapFee() external view returns (uint64);\n\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\n\n  function flashLoanFee() external view returns (uint256);\n\n  function maxAuctionLength() external view returns (uint256);\n\n  function minAuctionLength() external view returns (uint256);\n\n  function minBidIncrease() external view returns (uint256);\n\n  // Write functions.\n  function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external;\n\n  function createVault(\n      address _assetAddress,\n      bool is1155,\n      bool allowAllItems,\n      string calldata _name,\n      string calldata _symbol\n  ) external returns (address);\n\n  function setEligibilityManager(address _eligibilityManager) external;\n\n  function setFactoryFees(\n    uint256 _factoryMintFee,\n    uint256 _factoryRandomRedeemFee,\n    uint256 _factoryTargetRedeemFee,\n    uint256 _factoryRandomSwapFee,\n    uint256 _factoryTargetSwapFee,\n    uint256 _flashLoanFee\n  ) external;\n\n  function setFactoryThresholds(\n      uint256 _maxAuctionLength,\n      uint256 _minAuctionLength,\n      uint256 _minBidIncrease\n  ) external;\n\n  function setVaultFees(\n      uint256 vaultId,\n      uint256 _mintFee,\n      uint256 _randomRedeemFee,\n      uint256 _targetRedeemFee,\n      uint256 _randomSwapFee,\n      uint256 _targetSwapFee\n  ) external;\n\n  function disableVaultFees(uint256 vaultId) external;\n\n  event FactoryThresholdsUpdated(uint256 maxAuctionLength, uint256 minAuctionLength, uint256 minBidIncrease);\n  event EligibilityManagerUpdated(address oldEligManager, address newEligManager);\n  event VaultCreated(uint256 indexed vaultId, address curator, address vaultAddress, address assetAddress, string name, string symbol);\n  event VaultFeesUpdated(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\n  event VaultFeesDisabled(uint256 vaultId);\n  event FactoryFeesUpdated(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee, uint256 flashLoanFee);\n\n  error NotVault();\n  error FeeTooHigh();\n  error MaxAuctionLengthOutOfBounds();\n  error MinAuctionLengthOutOfBounds();\n  error MinBidIncreaseOutOfBounds();\n  error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPausable {\n    function isPaused(uint256 pauseId) external view returns (bool);\n}"
    },
    "src/contracts/interfaces/IVaultManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface IVaultManager {\n    function fnftSingleFactory() external view returns (address);\n\n    function fnftCollectionFactory() external view returns (address);\n\n    function excludedFromFees(address) external view returns (bool);\n\n    function feeDistributor() external view returns (address);\n\n    function __VaultManager_init(address _weth) external;\n\n    function WETH() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    function ifoFactory() external view returns (address);\n\n    function zapContract() external view returns (address);\n\n    function feeReceiver() external view returns (address payable);\n\n    function togglePaused() external;\n\n    function addVault(address _fnft) external returns (uint256 vaultId);\n\n    function setPriceOracle(address _priceOracle) external;\n\n    function setFeeDistributor(address _feeDistributor) external;\n\n    function setFeeExclusion(address _address, bool _excluded) external;\n\n    function setFeeReceiver(address payable _feeReceiver) external;\n\n    function setIFOFactory(address _ifoFactory) external;\n\n    function setZapContract(address _zapContract) external;\n\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external;\n\n    function setFNFTSingleFactory(address _fnftCollectionFactory) external;\n\n    function vault(uint256 vaultId) external view returns (address);\n\n    function vaults(uint256) external view returns (address);\n\n    function numVaults() external view returns (uint);\n\n    event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\n    event IFOFactoryUpdated(address oldIFOFactory, address newIFOFactory);\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\n    event ZapContractUpdated(address oldZapContract, address newZapContract);\n    event FNFTCollectionFactoryUpdated(address oldFNFTCollectionFactory, address newFNFTCollectionFactory);\n    event FNFTSingleFactoryUpdated(address oldFNFTSingleFactory, address newFNFTSingleFactory);\n    event VaultAdded(uint256 vaultId, address vault);\n    event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\n    event FeeExclusionUpdated(address target, bool excluded);\n\n    error FeeTooHigh();\n    error MaxAuctionLengthOutOfBounds();\n    error MaxReserveFactorTooLow();\n    error MinAuctionLengthOutOfBounds();\n    error MinBidIncreaseOutOfBounds();\n    error MinReserveFactorTooHigh();\n    error MinVotePercentageTooHigh();\n    error MultiplierTooLow();\n    error OnlyFactory();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/token/ERC20FlashMintUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashLenderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./ERC20Upgradeable.sol\";\n\n/**\n * @dev Implementation of the ERC3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * _Available since v4.1._\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {\n    function __ERC20FlashMint_init() internal onlyInitializing {\n    }\n\n    function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ON_RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error ExceedsMaxFlashLoan();\n    error FlashLoanNotRepaid();\n    error InvalidFlashLoanReturnValue();\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amont of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;\n    }\n\n    function _flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) internal returns (bool) {\n        if (amount > maxFlashLoan(token)) revert ExceedsMaxFlashLoan();\n\n        _mint(address(receiver), amount);\n        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != _ON_RETURN_VALUE) revert InvalidFlashLoanReturnValue();\n        uint256 currentAllowance = allowance(address(receiver), address(this));\n        if (amount + fee > currentAllowance) revert FlashLoanNotRepaid();\n\n        _approve(address(receiver), address(this), currentAllowance - amount - fee);\n\n        _burn(address(receiver), amount);\n        _chargeAndDistributeFees(address(receiver), fee);\n\n        return true;\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "src/contracts/interfaces/ILPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./IStakingTokenProvider.sol\";\nimport \"../token/LPStakingXTokenUpgradeable.sol\";\n\ninterface ILPStaking {\n    struct StakingPool {\n        address stakingToken;\n        address baseToken;\n    }\n\n    function vaultManager() external view returns (IVaultManager);\n\n    function stakingTokenProvider() external view returns (IStakingTokenProvider);\n\n    function lpStakingXToken() external view returns (LPStakingXTokenUpgradeable);\n\n    function vaultStakingInfo(uint256) external view returns (address, address);\n\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external;\n\n    function setStakingTokenProvider(address _stakingTokenProvider) external;\n\n    function addPoolForVault(uint256 vaultId) external;\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external;\n\n    function updatePoolForVault(uint256 vaultId) external;\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n\n    function deposit(uint256 vaultId, uint256 amount) external;\n\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\n\n    function exit(uint256 vaultId) external;\n\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external;\n\n    function emergencyExit(address _stakingToken, address _baseToken) external;\n\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external;\n\n    function claimRewardsTo(uint256 vaultId, address to) external;\n\n    function claimMultipleRewards(uint256[] calldata vaultIds) external;\n\n    function xToken(uint256 vaultId) external view returns (LPStakingXTokenUpgradeable);\n\n    function xTokenAddr(address stakedToken, address baseToken) external view returns (address);\n\n    function balanceOf(uint256 vaultId, address addr) external view returns (uint256);\n\n    function lockedUntil(uint256 vaultId, address who) external view returns (uint256);\n\n    function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256);\n\n    function xToken(StakingPool memory pool) external view returns (LPStakingXTokenUpgradeable);\n\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) external;\n\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\n    event StakingPoolUpdated(uint256 vaultId, address xToken);\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\n    event LPDeposited(uint256 vaultId, uint256 amount, address xToken, address sender);\n    event XTokenWithdrawn(uint256 vaultId, uint256 amount, address xToken, address sender);\n    event StakingTokenProviderUpdated(address oldStakingTokenProvider, address newStakingTokenProvider);\n\n    error NotAPool();\n    error NotDeployingProperDistro();\n    error NotExcludedFromFees();\n    error NothingToMigrate();\n    error PoolAlreadyExists();\n    error PoolDoesNotExist();\n    error LPStakingXTokenAlreadySet();\n    error TimelockTooLong();\n    error VaultManagerAlreadySet();\n    error VaultManagerNotSet();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IFNFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IVaultManager.sol\";\nimport \"./ITimelockExcludeList.sol\";\n\n\ninterface IFNFTStaking {\n    function vaultManager() external view returns (IVaultManager);\n\n    function inventoryLockTimeErc20() external view returns (uint256);\n\n    function timelockExcludeList() external view returns (ITimelockExcludeList);\n\n    function __FNFTStaking_init(address _vaultManager) external;\n\n    function setTimelockExcludeList(address _timelockExcludeList) external;\n\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external;\n\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) external returns (bool);\n\n    function deployXTokenForVault(uint256 vaultId) external;\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n\n    function deposit(uint256 vaultId, uint256 _amount) external;\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external returns (uint256);\n\n    function withdraw(uint256 vaultId, uint256 _share) external;\n\n    function xTokenShareValue(uint256 vaultId) external returns (uint256);\n\n    function timelockUntil(uint256 vaultId, address who) external returns (uint256);\n\n    function balanceOf(uint256 vaultId, address who) external returns (uint256);\n\n    function xTokenAddr(address baseToken) external returns (address);\n\n    function vaultXToken(uint256 vaultId) external view returns (address);\n\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\n    event BaseTokenDeposited(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, uint256 timelockUntil, address sender);\n    event XTokenWithdrawn(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, address sender);\n\n    event InventoryLockTimeErc20Updated(uint256 oldInventoryLockTimeErc20, uint256 newInventoryLockTimeErc20);\n    event TimelockExcludeListUpdated(address oldTimelockExcludeList, address newTimelockExcludeList);\n\n    error LockTooLong();\n    error NotExcludedFromFees();\n    error NotZapContract();\n    error XTokenNotDeployed();\n\n}"
    },
    "src/contracts/interfaces/IStakingTokenProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IStakingTokenProvider {\n    function uniLikeExchange() external returns (address);\n\n    function defaultPairedToken() external returns (address);\n\n    function defaultPrefix() external returns (string memory);\n\n    function pairedToken(address) external returns (address);\n\n    function pairedPrefix(address) external returns (string memory);\n\n    function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) external;\n\n    function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external;\n\n    function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external;\n\n    function stakingTokenForVaultToken(address _vaultToken) external view returns (address);\n\n    function nameForStakingToken(address _vaultToken) external view returns (string memory);\n\n    function pairForVaultToken(address _vaultToken, address _pairedToken) external view returns (address);\n\n    event DefaultPairedTokenUpdated(address oldDefaultPairedToken, address newDefaultPairedToken);\n    event PairedTokenForVaultUpdated(address vaultToken, address oldPairedtoken, address newPairedToken);\n\n    error IdenticalAddress();\n    error ZeroAddress();\n}"
    },
    "src/contracts/token/LPStakingXTokenUpgradeable.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title Reward-Paying Token (renamed from Dividend)\n/// @author Roger Wu (https://github.com/roger-wu)\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute a target token\n///  to token holders as dividends and allows token holders to withdraw their dividends.\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\ncontract LPStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  IERC20Upgradeable public target;\n\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n  // For more discussion about choosing the value of `magnitude`,\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedRewardPerShare;\n\n  // About dividendCorrection:\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n  //   `dividendOf(_user)` should not be changed,\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n  mapping(address => int256) internal magnifiedRewardCorrections;\n  mapping(address => uint256) internal withdrawnRewards;\n\n  mapping(address => uint256) internal timelock;\n\n  event Timelocked(address user, uint256 amount, uint256 until);\n\n  error UserIsLocked();\n  error ZeroAmount();\n  error ZeroSupply();\n\n  function __LPStakingXToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\n    __Ownable_init();\n    __ERC20_init(_name, _symbol);\n    target = _target;\n  }\n\n  function transfer(address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(_msgSender(), recipient, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20}.\n    *\n    * Requirements:\n    *\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(sender, recipient, amount);\n      _approve(sender, _msgSender(), allowance(sender, _msgSender()) - amount);\n      return true;\n  }\n\n  function mint(address account, uint256 amount) public onlyOwner virtual {\n      _mint(account, amount);\n  }\n\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\n    uint256 timelockFinish = block.timestamp + timelockLength;\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, amount, timelockFinish);\n    _mint(account, amount);\n  }\n\n  function timelockUntil(address account) public view returns (uint256) {\n    return timelock[account];\n  }\n\n  /**\n    * @dev Destroys `amount` tokens from `account`, without deducting from the caller's\n    * allowance. Dangerous.\n    *\n    * See {ERC20-_burn} and {ERC20-allowance}.\n    */\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\n      _burn(account, amount);\n  }\n\n  /// @notice Distributes target to token holders as dividends.\n  /// @dev It reverts if the total supply of tokens is 0.\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\n  /// About undistributed target tokens:\n  ///   In each distribution, there is a small amount of target not distributed,\n  ///     the magnified amount of which is\n  ///     `(amount * magnitude) % totalSupply()`.\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\n  ///     (de-magnified) in a distribution can be less than 1 wei.\n  ///   We can actually keep track of the undistributed target in a distribution\n  ///     and try to distribute it in the next distribution,\n  ///     but keeping track of such data on-chain costs much more than\n  ///     the saved target, so we don't do that.\n  function distributeRewards(uint amount) external virtual onlyOwner {\n    if (totalSupply() == 0) revert ZeroSupply();\n    if (amount == 0) revert ZeroAmount();\n\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\n    magnifiedRewardPerShare = magnifiedRewardPerShare + (amount * magnitude / totalSupply());\n\n    emit RewardsDistributed(msg.sender, amount);\n  }\n\n  /// @notice Withdraws the target distributed to the sender.\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\n  function withdrawReward(address user) external onlyOwner {\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\n    if (_withdrawableReward > 0) {\n      withdrawnRewards[user] = withdrawnRewards[user] + _withdrawableReward;\n      target.safeTransfer(user, _withdrawableReward);\n      emit RewardWithdrawn(user, _withdrawableReward);\n    }\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) public view returns(uint256) {\n    return withdrawableRewardOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\n    return accumulativeRewardOf(_owner) - withdrawnRewards[_owner];\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\n    return withdrawnRewards[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\n    return ((magnifiedRewardPerShare * balanceOf(_owner)).toInt256() + magnifiedRewardCorrections[_owner]).toUint256() / magnitude;\n  }\n\n  /// @dev Internal function that transfer tokens from one address to another.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param from The address to transfer from.\n  /// @param to The address to transfer to.\n  /// @param value The amount to be transferred.\n  function _transfer(address from, address to, uint256 value) internal override {\n    if (timelock[from] >= block.timestamp) revert UserIsLocked();\n    super._transfer(from, to, value);\n\n    int256 _magCorrection = (magnifiedRewardPerShare * value).toInt256();\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from] + _magCorrection;\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to] - _magCorrection;\n  }\n\n  /// @dev Internal function that mints tokens to an account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] - (magnifiedRewardPerShare * value).toInt256();\n  }\n\n  /// @dev Internal function that burns an amount of the token of a given account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _burn(address account, uint256 value) internal override {\n    if (timelock[account] >= block.timestamp) revert UserIsLocked();\n    super._burn(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] + (magnifiedRewardPerShare * value).toInt256();\n  }\n\n\n  /// @dev This event MUST emit when target is distributed to token holders.\n  /// @param from The address which sends target to this contract.\n  /// @param weiAmount The amount of distributed target in wei.\n  event RewardsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws target from this contract.\n  /// @param weiAmount The amount of withdrawn target in wei.\n  event RewardWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}"
    },
    "src/contracts/token/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _setMetadata(string memory name_, string memory symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/contracts/interfaces/ITimelockExcludeList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface ITimelockExcludeList {\n    function isExcluded(address addr, uint256 vaultId) external view returns (bool);\n}"
    },
    "src/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function childImplementation() external view returns (address);\n    function upgradeChildTo(address newImplementation) external;\n}"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashLenderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrowerUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLenderUpgradeable {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/token/FNFTStakingXTokenUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./ERC20Upgradeable.sol\";\n\n// XTokens let you come in with some vault tokens, and leave with more! The longer you stay, the more vault tokens you get.\n//\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\ncontract FNFTStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 internal constant MAX_TIMELOCK = 2592000;\n    IERC20Upgradeable public baseToken;\n\n    mapping(address => uint256) internal timelock;\n\n    event Timelocked(address user, uint256 until);\n\n    error LockTooLong();\n    error UserIsLocked();\n\n    function __FNFTStakingXToken_init(address _baseToken, string memory name, string memory symbol) public initializer {\n        __Ownable_init();\n        __ERC20_init(name, symbol);\n        baseToken = IERC20Upgradeable(_baseToken);\n    }\n\n    function burnXTokens(address who, uint256 _share) external onlyOwner returns (uint256) {\n        // Gets the amount of xToken in existence\n        uint256 totalShares = totalSupply();\n        // Calculates the amount of base tokens the xToken is worth\n        uint256 what = (_share * baseToken.balanceOf(address(this))) / totalShares;\n        _burn(who, _share);\n        baseToken.safeTransfer(who, what);\n        return what;\n    }\n\n    // Needs to be called BEFORE new base tokens are deposited.\n    function mintXTokens(address account, uint256 _amount, uint256 timelockLength) external onlyOwner returns (uint256) {\n        // Gets the amount of Base Token locked in the contract\n        uint256 totalBaseToken = baseToken.balanceOf(address(this));\n        // Gets the amount of xTokens in existence\n        uint256 totalShares = totalSupply();\n        // If no xTokens exist, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalBaseToken == 0) {\n            _timelockMint(account, _amount, timelockLength);\n            return _amount;\n        }\n        // Calculate and mint the amount of xTokens the base tokens are worth. The ratio will change overtime, as xTokens are burned/minted and base tokens deposited + gained from fees / withdrawn.\n        else {\n            uint256 what = (_amount * totalShares) / totalBaseToken;\n            _timelockMint(account, what, timelockLength);\n            return what;\n        }\n    }\n\n    function timelockUntil(address account) external view returns (uint256) {\n        return timelock[account];\n    }\n\n    function timelockAccount(address account, uint256 timelockLength) public onlyOwner {\n        if (timelockLength >= MAX_TIMELOCK) revert LockTooLong();\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        if (timelockFinish > timelock[account]) {\n            timelock[account] = timelockFinish;\n            emit Timelocked(account, timelockFinish);\n        }\n    }\n\n    function _burn(address who, uint256 amount) internal override {\n        if (timelock[who] >= block.timestamp) revert UserIsLocked();\n        super._burn(who, amount);\n    }\n\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal {\n        timelockAccount(account, timelockLength);\n        _mint(account, amount);\n    }\n\n    function _transfer(address from, address to, uint256 value) internal override {\n        if (timelock[from] >= block.timestamp) revert UserIsLocked();\n        super._transfer(from, to, value);\n    }\n}"
    },
    "src/contracts/StakingTokenProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n// Author: 0xKiwi.\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IStakingTokenProvider.sol\";\n\ncontract StakingTokenProvider is IStakingTokenProvider, OwnableUpgradeable {\n  mapping(address => string) public override pairedPrefix;\n  mapping(address => address) public override pairedToken;\n\n  address public override defaultPairedToken;\n  address public override uniLikeExchange;\n\n  string public override defaultPrefix;\n\n  // This is an address provder to allow us to abstract out what liquidity\n  // our vault tokens should be paired with.\n  function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) public override initializer {\n    __Ownable_init();\n    if (_uniLikeExchange == address(0)) revert ZeroAddress();\n    if (_defaultPairedtoken == address(0)) revert ZeroAddress();\n    uniLikeExchange = _uniLikeExchange;\n    defaultPairedToken = _defaultPairedtoken;\n    defaultPrefix = _defaultPrefix;\n  }\n\n  function nameForStakingToken(address _vaultToken) external view override returns (string memory) {\n    string memory _pairedPrefix = pairedPrefix[_vaultToken];\n    if (bytes(_pairedPrefix).length == 0) {\n      _pairedPrefix = defaultPrefix;\n    }\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n\n    string memory symbol1 = IERC20Metadata(_vaultToken).symbol();\n    string memory symbol2 = IERC20Metadata(_pairedToken).symbol();\n    return string(abi.encodePacked(_pairedPrefix, symbol1, symbol2));\n  }\n\n  function pairForVaultToken(address _vaultToken, address _pairedToken) external view override returns (address) {\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n\n  function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external override onlyOwner {\n    emit DefaultPairedTokenUpdated(defaultPairedToken, _defaultPairedToken);\n    defaultPairedToken = _defaultPairedToken;\n    defaultPrefix = _defaultPrefix;\n  }\n\n  function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external override onlyOwner {\n    if (_newPairedToken == address(0)) revert ZeroAddress();\n    emit PairedTokenForVaultUpdated(_vaultToken, pairedToken[_vaultToken], _newPairedToken);\n    pairedToken[_vaultToken] = _newPairedToken;\n    pairedPrefix[_vaultToken] = _newPrefix;\n  }\n\n  function stakingTokenForVaultToken(address _vaultToken) external view override returns (address) {\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function _pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n      (address token0, address token1) = _sortTokens(tokenA, tokenB);\n      pair = address(uint160(uint256(keccak256(abi.encodePacked(\n              hex'ff',\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\n      )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      if (tokenA == tokenB) revert IdenticalAddress();\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      if (token0 == address(0)) revert ZeroAddress();\n  }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/contracts/LPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/IStakingTokenProvider.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./token/LPStakingXTokenUpgradeable.sol\";\nimport \"./util/Pausable.sol\";\n\n// Pausing codes for LP staking are:\n// 10: Deposit\n\ncontract LPStaking is ILPStaking, Pausable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    mapping(uint256 => StakingPool) public override vaultStakingInfo;\n\n    IStakingTokenProvider public override stakingTokenProvider;\n    LPStakingXTokenUpgradeable public override lpStakingXToken;\n    IVaultManager public override vaultManager;\n\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external override initializer {\n        __Ownable_init();\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\n        if (address(lpStakingXToken) != address(0)) revert LPStakingXTokenAlreadySet();\n        vaultManager = IVaultManager(_vaultManager);\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\n        lpStakingXToken = new LPStakingXTokenUpgradeable();\n        lpStakingXToken.__LPStakingXToken_init(IERC20Upgradeable(address(0)), \"\", \"\");\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\n        _;\n    }\n\n    function addPoolForVault(uint256 vaultId) external override onlyAdmin {\n        if (address(vaultManager) == address(0)) revert VaultManagerNotSet();\n        if (vaultStakingInfo[vaultId].stakingToken != address(0)) revert PoolAlreadyExists();\n        address _baseToken = vaultManager.vault(vaultId);\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_baseToken);\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        vaultStakingInfo[vaultId] = pool;\n        address newXToken = _deployDividendToken(pool);\n        emit StakingPoolCreated(vaultId, newXToken, _baseToken);\n    }\n\n    function deposit(uint256 vaultId, uint256 amount) external override {\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n\n        // If the user has an existing timelock, check if it is in the future.\n        uint256 currentTimelock = _xToken.timelockUntil(msg.sender);\n        if (currentTimelock > block.timestamp) {\n            // Maintain the same timelock if they already have one.\n            // We do this instead of patching in the token because\n            // the reward distribution token contracts as currently deployed are not upgradeable.\n            _xToken.timelockMint(msg.sender, amount, currentTimelock-block.timestamp);\n        } else {\n            // Timelock for 2 seconds if they don't already have a timelock to prevent flash loans.\n            _xToken.timelockMint(msg.sender, amount, 2);\n        }\n\n        emit LPDeposited(vaultId, amount, address(_xToken), msg.sender);\n    }\n\n    function claimMultipleRewards(uint256[] calldata vaultIds) external override {\n        uint256 length = vaultIds.length;\n        for (uint256 i; i < length;) {\n            claimRewardsTo(vaultIds[i], msg.sender);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function emergencyExit(address _stakingToken, address _baseToken) external override {\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        LPStakingXTokenUpgradeable dist = xToken(pool);\n        if (!_isContract(address(dist))) revert NotAPool();\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external override {\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\n        LPStakingXTokenUpgradeable dist = xToken(pool);\n        if (!_isContract(address(dist))) revert NotAPool();\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function exit(uint256 vaultId) external override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\n    }\n\n    function lockedLPBalance(uint256 vaultId, address who) external view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        if(block.timestamp > _xToken.timelockUntil(who)) {\n            return 0;\n        }\n        return _xToken.balanceOf(who);\n    }\n\n    function lockedUntil(uint256 vaultId, address who) external view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        return _xToken.timelockUntil(who);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external override onlyAdmin returns (bool) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            // In case the pair is updated, but not yet\n            return false;\n        }\n\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!_isContract(address(_xToken)) || _xToken.totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the vault only needs to approve this contract.\n        IERC20Upgradeable(pool.baseToken).safeTransferFrom(msg.sender, address(_xToken), amount);\n        _xToken.distributeRewards(amount);\n        emit FeesReceived(vaultId, amount, address(_xToken));\n        return true;\n    }\n\n    function xToken(uint256 vaultId) external view override returns (LPStakingXTokenUpgradeable) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return LPStakingXTokenUpgradeable(address(0));\n        }\n        return xToken(pool);\n    }\n\n    function setStakingTokenProvider(address _stakingTokenProvider) external override onlyOwner {\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\n        emit StakingTokenProviderUpdated(address(stakingTokenProvider), _stakingTokenProvider);\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\n    }\n\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external override {\n        if (timelockLength >= 2592000) revert TimelockTooLong();\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        xToken(pool).timelockMint(account, amount, timelockLength);\n    }\n\n    // In case the provider changes, this lets the pool be updated. Anyone can call it.\n    function updatePoolForVault(uint256 vaultId) public override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        // Not letting people use this function to create new pools.\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.baseToken);\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.baseToken);\n        vaultStakingInfo[vaultId] = newPool;\n\n        // If the pool is already deployed, ignore the update.\n        address addr = address(xToken(newPool));\n        if (_isContract(addr)) {\n            return;\n        }\n        address newXToken = _deployDividendToken(newPool);\n        emit StakingPoolUpdated(vaultId, newXToken);\n    }\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external override {\n        uint256 length = vaultIds.length;\n        for (uint256 i; i < length;) {\n            updatePoolForVault(vaultIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, to);\n        _withdraw(pool, amount, to);\n\n        emit XTokenWithdrawn(vaultId, amount, address(xToken(pool)), to);\n    }\n\n    function balanceOf(uint256 vaultId, address addr) public view override returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        if (!_isContract(address(_xToken))) revert NotAPool();\n        return _xToken.balanceOf(addr);\n    }\n\n    function claimRewardsTo(uint256 vaultId, address to) public override {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, to);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xToken(StakingPool memory pool) public view override returns (LPStakingXTokenUpgradeable) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2) /* small nonce to change tokens */));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(lpStakingXToken), salt);\n        return LPStakingXTokenUpgradeable(tokenAddr);\n    }\n\n    function xTokenAddr(address stakedToken, address baseToken) public view override returns (address) {\n        StakingPool memory pool = StakingPool(stakedToken, baseToken);\n        return address(xToken(pool));\n    }\n\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) public override onlyOwner {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\n        _xToken.burnFrom(from, amount);\n        _xToken.mint(to, amount);\n    }\n\n    function _claimRewards(StakingPool memory pool, address account) internal {\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        xToken(pool).withdrawReward(account);\n    }\n\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\n        // Changed to use new nonces.\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2)));\n        address _xToken = ClonesUpgradeable.cloneDeterministic(address(lpStakingXToken), salt);\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.baseToken);\n        LPStakingXTokenUpgradeable(_xToken).__LPStakingXToken_init(IERC20Upgradeable(pool.baseToken), name, name);\n        return _xToken;\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\n        xToken(pool).burnFrom(account, amount);\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(account, amount);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/contracts/util/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract Pausable is OwnableUpgradeable {\n\n    function __Pausable_init() internal initializer {\n        __Ownable_init();\n    }\n\n    event SetIsGuardian(address addr, bool isGuardian);\n    event SetPaused(uint256 lockId, bool paused);\n\n    mapping(address => bool) public isGuardian;\n    mapping(uint256 => bool) public isPaused;\n    // 0  : createVault\n    // 1  : mint\n    // 2  : redeem\n    // 3  : swap\n    // 4  : auction\n    // 5  : flashloan\n    // 6  : fee\n    // 7  : price\n    // 10 : stake\n\n    error Paused();\n    error Unauthorized();\n\n    function onlyOwnerIfPaused(uint256 lockId) public view virtual {\n        if (isPaused[lockId] && msg.sender != owner()) revert Paused();\n    }\n\n    function pause(uint256 lockId) public virtual {\n        if (!isGuardian[msg.sender]) revert Unauthorized();\n        isPaused[lockId] = true;\n        emit SetPaused(lockId, true);\n    }\n\n    function setIsGuardian(address _address, bool _isGuardian) public virtual onlyOwner {\n        isGuardian[_address] = _isGuardian;\n        emit SetIsGuardian(_address, _isGuardian);\n    }\n\n    function unpause(uint256 lockId)\n        public\n        virtual\n        onlyOwner\n    {\n        isPaused[lockId] = false;\n        emit SetPaused(lockId, false);\n    }\n}\n"
    },
    "src/contracts/proxy/Deployer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../VaultManager.sol\";\nimport \"../FNFTCollectionFactory.sol\";\nimport \"../FeeDistributor.sol\";\nimport \"../FNFTStaking.sol\";\nimport \"../LPStaking.sol\";\nimport \"../StakingTokenProvider.sol\";\nimport \"./AdminUpgradeabilityProxy.sol\";\nimport \"./IMultiProxyController.sol\";\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Deployer is Ownable {\n    event ProxyDeployed(\n        bytes32 indexed identifier,\n        address logic,\n        address creator\n    );\n\n    error NoController();\n\n    IMultiProxyController public proxyController;\n\n    bytes32 constant public FNFT_COLLECTION_FACTORY = bytes32(0x464e4654436f6c6c656374696f6e466163746f72790000000000000000000000);\n    bytes32 constant public VAULT_MANAGER = bytes32(0x5661756c744d616e616765720000000000000000000000000000000000000000);\n    bytes32 constant public FEE_DISTRIBUTOR = bytes32(0x4665654469737472696275746f72000000000000000000000000000000000000);\n    bytes32 constant public INVENTORY_STAKING = bytes32(0x496e76656e746f72795374616b696e6700000000000000000000000000000000);\n    bytes32 constant public LP_STAKING = bytes32(0x4c505374616b696e670000000000000000000000000000000000000000000000);\n    bytes32 constant public STAKING_TOKEN_PROVIDER = bytes32(0x5374616b696e67546f6b656e50726f7669646572000000000000000000000000);\n\n    // Gov\n\n    function setProxyController(address _proxyController) external onlyOwner {\n        proxyController = IMultiProxyController(_proxyController);\n    }\n\n    /// @notice the function to deploy FeeDistributor\n    /// @param _logic the implementation\n    function deployFeeDistributor(address _logic, address vaultManager, address lpStaking, address treasury) external onlyOwner returns (address feeDistributor) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FeeDistributor.__FeeDistributor_init.selector,\n            vaultManager,\n            lpStaking,\n            treasury\n        );\n\n        feeDistributor = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(feeDistributor).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(FEE_DISTRIBUTOR, feeDistributor);\n\n        emit ProxyDeployed(FEE_DISTRIBUTOR, feeDistributor, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTCollectionFactory\n    /// @param _logic the implementation\n    function deployVaultManager(\n        address _logic,\n        address _weth\n    ) external onlyOwner returns (address vaultManager) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            VaultManager.__VaultManager_init.selector,\n            _weth\n        );\n\n        vaultManager = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(vaultManager).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(VAULT_MANAGER, vaultManager);\n\n        emit ProxyDeployed(VAULT_MANAGER, vaultManager, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTCollectionFactory\n    /// @param _logic the implementation\n    /// @param _vaultManager variable needed for FNFTCollectionFactory\n    function deployFNFTCollectionFactory(\n        address _logic,\n        address _vaultManager,\n        address _fnftCollection\n    ) external onlyOwner returns (address factory) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FNFTCollectionFactory.__FNFTCollectionFactory_init.selector,\n            _vaultManager,\n            _fnftCollection\n        );\n\n        factory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(factory).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(FNFT_COLLECTION_FACTORY, factory);\n\n        emit ProxyDeployed(FNFT_COLLECTION_FACTORY, factory, msg.sender);\n    }\n\n    /// @notice the function to deploy LPStaking\n    /// @param _logic the implementation\n    function deployLPStaking(address _logic, address vaultManager, address stakingTokenProvider) external onlyOwner returns (address lpStaking) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            LPStaking.__LPStaking__init.selector,\n            vaultManager,\n            stakingTokenProvider\n        );\n\n        lpStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(lpStaking).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(LP_STAKING, lpStaking);\n\n        emit ProxyDeployed(LP_STAKING, lpStaking, msg.sender);\n    }\n\n    /// @notice the function to deploy FNFTStaking\n    /// @param _logic the implementation\n    function deployFNFTStaking(address _logic, address fnftCollectionFactory) external onlyOwner returns (address fnftStaking) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            FNFTStaking.__FNFTStaking_init.selector,\n            fnftCollectionFactory\n        );\n\n        fnftStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(fnftStaking).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(INVENTORY_STAKING, fnftStaking);\n\n        emit ProxyDeployed(INVENTORY_STAKING, fnftStaking, msg.sender);\n    }\n\n    /// @notice the function to deploy StakingTokenProvider\n    /// @param _logic the implementation\n    function deployStakingTokenProvider(address _logic, address uniswapV2Factory, address defaultPairedToken, string memory defaultPrefix) external onlyOwner returns (address stakingTokenProvider) {\n        if (address(proxyController) == address(0)) revert NoController();\n\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            StakingTokenProvider.__StakingTokenProvider_init.selector,\n            uniswapV2Factory,\n            defaultPairedToken,\n            defaultPrefix\n        );\n\n        stakingTokenProvider = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\n        IOwnable(stakingTokenProvider).transferOwnership(msg.sender);\n\n        proxyController.deployerUpdateProxy(STAKING_TOKEN_PROVIDER, stakingTokenProvider);\n\n        emit ProxyDeployed(STAKING_TOKEN_PROVIDER, stakingTokenProvider, msg.sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/contracts/VaultManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\n\ncontract VaultManager is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    IVaultManager\n{\n    mapping(address => bool) public override excludedFromFees;\n\n    address[] public override vaults;\n\n    address public override feeDistributor;\n\n    /// @notice the address who receives auction fees\n    address payable public override feeReceiver;\n\n    address public override fnftSingleFactory;\n\n    address public override fnftCollectionFactory;\n\n    address public override ifoFactory;\n\n    address public override priceOracle;\n\n    address public override zapContract;\n\n    address public override WETH;\n\n    function __VaultManager_init(address _weth) external override initializer {\n        __Ownable_init();\n        __Pausable_init();\n        WETH = _weth;\n        feeReceiver = payable(msg.sender);\n    }\n\n    function addVault(address _fnft) external override returns (uint256 vaultId) {\n        if (_fnft == address(0)) revert ZeroAddress();\n        address _feeDistributor = feeDistributor;\n        if (_feeDistributor == address(0)) revert ZeroAddress();\n        if (msg.sender != fnftCollectionFactory && msg.sender != fnftSingleFactory) revert OnlyFactory();\n        vaultId = vaults.length;\n        vaults.push(_fnft);\n        IFeeDistributor(_feeDistributor).initializeVaultReceivers(vaultId);\n        emit VaultAdded(vaultId, _fnft);\n    }\n\n    function numVaults() external view override returns (uint) {\n        return vaults.length;\n    }\n\n    function setFeeDistributor(address _feeDistributor) public override onlyOwner {\n        if (_feeDistributor == address(0)) revert ZeroAddress();\n        emit FeeDistributorUpdated(feeDistributor, _feeDistributor);\n        feeDistributor = _feeDistributor;\n    }\n\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\n        if (_feeReceiver == address(0)) revert ZeroAddress();\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\n        feeReceiver = _feeReceiver;\n    }\n\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external override onlyOwner {\n        if (_fnftCollectionFactory == address(0)) revert ZeroAddress();\n        emit FNFTCollectionFactoryUpdated(fnftCollectionFactory, _fnftCollectionFactory);\n        fnftCollectionFactory = _fnftCollectionFactory;\n    }\n\n    function setFNFTSingleFactory(address _fnftSingleFactory) external override onlyOwner {\n        if (_fnftSingleFactory == address(0)) revert ZeroAddress();\n        emit FNFTSingleFactoryUpdated(fnftSingleFactory, _fnftSingleFactory);\n        fnftSingleFactory = _fnftSingleFactory;\n    }\n\n    function setIFOFactory(address _ifoFactory) external override onlyOwner {\n        emit IFOFactoryUpdated(ifoFactory, _ifoFactory);\n        ifoFactory = _ifoFactory;\n    }\n\n    function setPriceOracle(address _priceOracle) external override onlyOwner {\n        emit PriceOracleUpdated(priceOracle, _priceOracle);\n        priceOracle = _priceOracle;\n    }\n\n    function setZapContract(address _zapContract) external override onlyOwner {\n        if (_zapContract == address(0)) revert ZeroAddress();\n        emit ZapContractUpdated(zapContract, _zapContract);\n        zapContract = _zapContract;\n    }\n\n    function togglePaused() external override onlyOwner {\n        paused() ? _unpause() : _pause();\n    }\n\n    function vault(uint256 vaultId) external view override returns (address) {\n        return vaults[vaultId];\n    }\n\n    function setFeeExclusion(address _address, bool _excluded) public override onlyOwner {\n        emit FeeExclusionUpdated(_address, _excluded);\n        excludedFromFees[_address] = _excluded;\n    }\n}\n"
    },
    "src/contracts/FNFTCollectionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./interfaces/IFNFTCollectionFactory.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./proxy/BeaconProxy.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\nimport \"./util/Pausable.sol\";\n\n// Authors: @0xKiwi_ and @alexgausman.\n\ncontract FNFTCollectionFactory is\n    IFNFTCollectionFactory,\n    Pausable,\n    BeaconUpgradeable\n{\n    mapping(uint256 => VaultFees) private _vaultFees;\n\n    uint64 public override factoryMintFee;\n    uint64 public override factoryRandomRedeemFee;\n    uint64 public override factoryRandomSwapFee;\n    uint64 public override factoryTargetRedeemFee;\n\n    IVaultManager public override vaultManager;\n    uint64 public override factoryTargetSwapFee;\n\n    address public override eligibilityManager;\n    uint256 public override flashLoanFee;\n\n    /// @notice the maximum auction length\n    uint256 public override maxAuctionLength;\n\n    /// @notice the minimum auction length\n    uint256 public override minAuctionLength;\n\n    /// @notice the % bid increase required for a new bid\n    uint256 public override minBidIncrease;\n\n    function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external override initializer {\n        if (_vaultManager == address(0)) revert ZeroAddress();\n        if (_fnftCollection == address(0)) revert ZeroAddress();\n        __Pausable_init();\n        __BeaconUpgradeable__init(_fnftCollection);\n        vaultManager = IVaultManager(_vaultManager);\n        factoryMintFee = uint64(0.1 ether);\n        factoryRandomRedeemFee = uint64(0.05 ether);\n        factoryTargetRedeemFee = uint64(0.1 ether);\n        factoryRandomSwapFee = uint64(0.05 ether);\n        factoryTargetSwapFee = uint64(0.1 ether);\n        maxAuctionLength = 2 weeks;\n        minAuctionLength = 3 days;\n        minBidIncrease = 500; // 5%\n    }\n\n    function createVault(\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems,\n        string memory _name,\n        string memory _symbol\n    ) external virtual override returns (address) {\n        onlyOwnerIfPaused(0);\n        if (childImplementation() == address(0)) revert ZeroAddress();\n        IVaultManager _vaultManager = vaultManager;\n        address fnftCollection = _deployVault(_name, _symbol, _assetAddress, is1155, allowAllItems);\n        uint vaultId = _vaultManager.addVault(fnftCollection);\n        emit VaultCreated(vaultId, msg.sender, fnftCollection, _assetAddress, _name, _symbol);\n        return fnftCollection;\n    }\n\n    function setEligibilityManager(address _eligibilityManager) external virtual override onlyOwner {\n        emit EligibilityManagerUpdated(eligibilityManager, _eligibilityManager);\n        eligibilityManager = _eligibilityManager;\n    }\n\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\n        VaultFees memory fees = _vaultFees[vaultId];\n        if (fees.active) {\n            return (\n                uint256(fees.mintFee),\n                uint256(fees.randomRedeemFee),\n                uint256(fees.targetRedeemFee),\n                uint256(fees.randomSwapFee),\n                uint256(fees.targetSwapFee)\n            );\n        }\n\n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\n    }\n\n    function disableVaultFees(uint256 vaultId) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaultManager.vault(vaultId);\n            if (msg.sender != vaultAddr) revert NotVault();\n        }\n        delete _vaultFees[vaultId];\n        emit VaultFeesDisabled(vaultId);\n    }\n\n    function setFactoryFees(\n        uint256 _factoryMintFee,\n        uint256 _factoryRandomRedeemFee,\n        uint256 _factoryTargetRedeemFee,\n        uint256 _factoryRandomSwapFee,\n        uint256 _factoryTargetSwapFee,\n        uint256 _flashLoanFee\n    ) public virtual override onlyOwner {\n        if (_factoryMintFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryRandomRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryTargetRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryRandomSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_factoryTargetSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_flashLoanFee > 500) revert FeeTooHigh();\n\n        factoryMintFee = uint64(_factoryMintFee);\n        factoryRandomRedeemFee = uint64(_factoryRandomRedeemFee);\n        factoryTargetRedeemFee = uint64(_factoryTargetRedeemFee);\n        factoryRandomSwapFee = uint64(_factoryRandomSwapFee);\n        factoryTargetSwapFee = uint64(_factoryTargetSwapFee);\n        flashLoanFee = _flashLoanFee;\n\n        emit FactoryFeesUpdated(\n            _factoryMintFee,\n            _factoryRandomRedeemFee,\n            _factoryTargetRedeemFee,\n            _factoryRandomSwapFee,\n            _factoryTargetSwapFee,\n            _flashLoanFee\n        );\n    }\n\n    function setFactoryThresholds(\n        uint256 _maxAuctionLength,\n        uint256 _minAuctionLength,\n        uint256 _minBidIncrease\n    ) public virtual override onlyOwner {\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\n\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\n\n        maxAuctionLength = _maxAuctionLength;\n        minAuctionLength = _minAuctionLength;\n        minBidIncrease = _minBidIncrease;\n\n        emit FactoryThresholdsUpdated(_maxAuctionLength, _minAuctionLength, _minBidIncrease);\n    }\n\n    function setVaultFees(\n        uint256 vaultId,\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaultManager.vault(vaultId);\n            if (msg.sender != vaultAddr) revert NotVault();\n        }\n        if (_mintFee > 0.5 ether) revert FeeTooHigh();\n        if (_randomRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_targetRedeemFee > 0.5 ether) revert FeeTooHigh();\n        if (_randomSwapFee > 0.5 ether) revert FeeTooHigh();\n        if (_targetSwapFee > 0.5 ether) revert FeeTooHigh();\n\n        _vaultFees[vaultId] = VaultFees(\n            true,\n            uint64(_mintFee),\n            uint64(_randomRedeemFee),\n            uint64(_targetRedeemFee),\n            uint64(_randomSwapFee),\n            uint64(_targetSwapFee)\n        );\n        emit VaultFeesUpdated(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    /// @dev 0x042f186c == FNFTCollection.__FNFTCollection_init.selector\n    function _deployVault(\n        string memory name,\n        string memory symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) internal returns (address) {\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            0x042f186c,\n            name,\n            symbol,\n            msg.sender,\n            _assetAddress,\n            is1155,\n            allowAllItems\n        );\n\n        address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\n\n        // Owner for administrative functions.\n        IOwnable(newBeaconProxy).transferOwnership(owner());\n\n        return newBeaconProxy;\n    }\n}"
    },
    "src/contracts/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./interfaces/IFNFTStaking.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./util/Pausable.sol\";\n\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuardUpgradeable, Pausable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  FeeReceiver[] public override feeReceivers;\n\n  IFNFTStaking public override fnftStaking;\n  ILPStaking public override lpStaking;\n  IVaultManager public override vaultManager;\n  address public override treasury;\n\n  // Total allocation points per vault.\n  uint256 public override allocTotal;\n  bool public override distributionPaused;\n\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external override initializer {\n    __Pausable_init();\n\n    vaultManager = IVaultManager(_vaultManager);\n\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, _lpStaking, true);\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    IVaultManager _vaultManager = vaultManager;\n    if (address(_vaultManager) == address(0)) revert ZeroAddress();\n    address _vault = _vaultManager.vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    }\n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i; i < length;) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        uint256 remaining = IERC20Upgradeable(_vault).allowance(address(this), _feeReceiver.receiver);\n        IERC20Upgradeable(_vault).safeApprove(_feeReceiver.receiver, 0);\n        leftover = remaining;\n      } else {\n        leftover = 0;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (leftover != 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\n    lpStaking.addPoolForVault(_vaultId);\n    IFNFTStaking _inventoryStaking = fnftStaking;\n    if (address(_inventoryStaking) != address(0))\n      _inventoryStaking.deployXTokenForVault(_vaultId);\n  }\n\n  function pauseFeeDistribution(bool _pause) external override onlyOwner {\n    distributionPaused = _pause;\n    emit DistributionPaused(_pause);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    if (_receiverIdx >= arrLength) revert OutOfBounds();\n    emit FeeReceiverRemoved(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit FeeReceiverAddressUpdated(oldReceiver, _address);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    if(_receiverIdx >= feeReceivers.length) revert OutOfBounds();\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit FeeReceiverAllocUpdated(feeReceiver.receiver, _allocPoint);\n  }\n\n  function setFNFTStakingAddress(address _inventoryStaking) public override onlyOwner {\n    fnftStaking = IFNFTStaking(_inventoryStaking);\n    emit FNFTStakingAddressUpdated(_inventoryStaking);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    if (_lpStaking == address(0)) revert ZeroAddress();\n    lpStaking = ILPStaking(_lpStaking);\n    emit LPStakingAddressUpdated(_lpStaking);\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    if (_treasury == address(0)) revert ZeroAddress();\n    treasury = _treasury;\n    emit TreasuryAddressUpdated(_treasury);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit FeeReceiverAdded(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).safeIncreaseAllowance(_receiver.receiver, amountToSend);\n\n      bytes memory payload = abi.encodeWithSelector(ILPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n      return true;\n    }\n  }\n}"
    },
    "src/contracts/FNFTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IFNFTCollection.sol\";\nimport \"./interfaces/IFNFTStaking.sol\";\nimport \"./util/Pausable.sol\";\nimport \"./proxy/BeaconUpgradeable.sol\";\nimport \"./proxy/Create2BeaconProxy.sol\";\nimport \"./token/FNFTStakingXTokenUpgradeable.sol\";\nimport \"./interfaces/ITimelockExcludeList.sol\";\n\n// Author: 0xKiwi.\n\n// Pausing codes for inventory staking are:\n// 10: Deposit\n\ncontract FNFTStaking is IFNFTStaking, Pausable, BeaconUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Small locktime to prevent flash deposits.\n    uint256 internal constant DEFAULT_LOCKTIME = 2;\n    bytes internal constant BEACON_CODE = type(Create2BeaconProxy).creationCode;\n\n    IVaultManager public override vaultManager;\n    ITimelockExcludeList public override timelockExcludeList;\n\n    uint256 public override inventoryLockTimeErc20;\n\n    function __FNFTStaking_init(address _vaultManager) external virtual override initializer {\n        __Ownable_init();\n        vaultManager = IVaultManager(_vaultManager);\n        address xTokenImpl = address(new FNFTStakingXTokenUpgradeable());\n        __BeaconUpgradeable__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\n        _;\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view override returns (uint256) {\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) external virtual override {\n        onlyOwnerIfPaused(10);\n\n        uint256 timelockTime = isAddressTimelockExcluded(msg.sender, vaultId) ? 0 : inventoryLockTimeErc20;\n\n        (IERC20Upgradeable baseToken, FNFTStakingXTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, timelockTime);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit BaseTokenDeposited(vaultId, _amount, xTokensMinted, timelockTime, msg.sender);\n    }\n\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) public view override returns (bool) {\n        if (address(timelockExcludeList) == address(0)) {\n            return false;\n        } else {\n            return timelockExcludeList.isExcluded(addr, vaultId);\n        }\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = vaultManager.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!_isContract(deployedXToken) || FNFTStakingXTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        emit FeesReceived(vaultId, amount, deployedXToken);\n        return true;\n    }\n\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external override onlyOwner {\n        if (_inventoryLockTimeErc20 > 14 days) revert LockTooLong();\n        emit InventoryLockTimeErc20Updated(inventoryLockTimeErc20, _inventoryLockTimeErc20);\n        inventoryLockTimeErc20 = _inventoryLockTimeErc20;\n    }\n\n    // TODO: timelock exclude list is not yet implemented\n    function setTimelockExcludeList(address _timelockExcludeList) external override onlyOwner {\n        emit TimelockExcludeListUpdated(address(timelockExcludeList), _timelockExcludeList);\n        timelockExcludeList = ITimelockExcludeList(_timelockExcludeList);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        if (msg.sender != vaultManager.zapContract()) revert NotZapContract();\n        // important for math that staking zap is excluded from fees\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit BaseTokenDeposited(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view override returns (uint256) {\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) external virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit XTokenWithdrawn(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\n        if (!_isContract(address(xToken))) revert XTokenNotDeployed();\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0\n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply()\n            : multiplier;\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = vaultManager.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (_isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit StakingPoolCreated(vaultId, xToken, baseToken);\n    }\n\n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = vaultManager.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        if (!_isContract(xToken)) revert XTokenNotDeployed();\n        return xToken;\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n\n    function _deployXToken(address baseToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(baseToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address deployedXToken = Create2.deploy(0, salt, BEACON_CODE);\n        FNFTStakingXTokenUpgradeable(deployedXToken).__FNFTStakingXToken_init(baseToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size != 0;\n    }\n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, FNFTStakingXTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n}\n"
    },
    "src/contracts/proxy/AdminUpgradeabilityProxy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _adm Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _adm, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    _setAdmin(_adm);\n  }\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}"
    },
    "src/contracts/proxy/IMultiProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IMultiProxyController {\n    function deployerUpdateProxy(bytes32 key, address proxy) external;\n}"
    },
    "src/contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IOwnable {    \n    function transferOwnership(address newOwner) external;\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "src/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).childImplementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).childImplementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}"
    },
    "src/contracts/proxy/BeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract BeaconUpgradeable is OwnableUpgradeable, IBeacon {\n    address private _childImplementation;\n\n    /**\n     * @dev Emitted when the child implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed childImplementation);\n\n    function __BeaconUpgradeable__init(address childImplementation_) public initializer {\n        _setChildImplementation(childImplementation_);\n    }\n\n    /**\n     * @dev Returns the current child implementation address.\n     */\n    function childImplementation() public view virtual override returns (address) {\n        return _childImplementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newChildImplementation` must be a contract.\n     */\n    function upgradeChildTo(address newChildImplementation) external virtual override onlyOwner {\n        _setChildImplementation(newChildImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newChildImplementation` must be a contract.\n     */\n    function _setChildImplementation(address newChildImplementation) private {\n        require(Address.isContract(newChildImplementation), \"UpgradeableBeacon: child implementation is not a contract\");\n        _childImplementation = newChildImplementation;\n        emit Upgraded(newChildImplementation);\n    }\n}"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n    * @dev Function that is run as the first thing in the fallback function.\n    * Can be redefined in derived contracts to add functionality.\n    * Redefinitions must call super._willFallback().\n    */\n    function _willFallback() internal virtual {\n    }\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}"
    },
    "src/contracts/proxy/Create2BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBeacon.sol\";\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n * Slightly modified to allow using beacon proxies with Create2.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract Create2BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor() payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(msg.sender, \"\");\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).childImplementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).childImplementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}"
    },
    "src/contracts/proxy/UpgradeabilityProxy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}"
    },
    "src/contracts/LPStakingZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IFeeDistributor.sol\";\nimport \"./interfaces/ILPStaking.sol\";\nimport \"./interfaces/ILPStakingZap.sol\";\nimport \"./interfaces/IUniswapV2Router.sol\";\nimport \"./interfaces/IVaultManager.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract LPStakingZap is ILPStakingZap, Ownable, ReentrancyGuard {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  IUniswapV2Router public immutable override router;\n  IVaultManager public immutable override vaultManager;\n  IWETH public immutable override WETH;\n\n  ILPStaking public override lpStaking;\n\n  uint256 public override lpLockTime = 48 hours;\n\n  constructor(address _vaultManager, address _router) Ownable() ReentrancyGuard() {\n    router = IUniswapV2Router(_router);\n    vaultManager = IVaultManager(_vaultManager);\n    address weth = IUniswapV2Router(_router).WETH();\n    WETH = IWETH(weth);\n    IERC20Upgradeable(weth).safeApprove(_router, type(uint256).max);\n  }\n\n  function assignLPStakingContract() public override {\n    if (address(lpStaking) != address(0)) revert NotZeroAddress();\n    IFeeDistributor feeDistributor = IFeeDistributor(IVaultManager(vaultManager).feeDistributor());\n    lpStaking = ILPStaking(feeDistributor.lpStaking());\n  }\n\n  receive() external payable {\n    if (msg.sender != address(WETH)) revert OnlyWETH();\n  }\n\n  function rescue(address token) external override onlyOwner {\n    if (token == address(0)) {\n      (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n      if (!success) revert CallFailed();\n    } else {\n      IERC20Upgradeable(token).safeTransfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n  }\n\n  function setLPLockTime(uint256 _lpLockTime) external override onlyOwner {\n    if (_lpLockTime > 7 days) revert LockTooLong();\n    emit LPLockTimeUpdated(lpLockTime, _lpLockTime);\n    lpLockTime = _lpLockTime;\n  }\n\n\tfunction stakeLiquidityETH(\n\t\tuint256 vaultId,\n    uint256 minTokenIn,\n    uint256 wethIn,\n    address to\n\t) external payable override nonReentrant returns (uint256, uint256, uint256) {\n\t\tif (to == address(0) || to == address(this)) revert InvalidDestination();\n\t\tWETH.deposit{value: msg.value}();\n\n    address vault = vaultManager.vault(vaultId);\n\n\t\treturn _addLiquidityAndLock(vaultId, vault, minTokenIn, msg.value, wethIn, to);\n\t}\n\n\tfunction stakeLiquidityWETH(\n\t\tuint256 vaultId,\n    uint256 minTokenIn,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n\t) external override nonReentrant returns (uint256, uint256, uint256) {\n\t\tif (to == address(0) || to == address(this)) revert InvalidDestination();\n\t\tIERC20Upgradeable(address(WETH)).safeTransferFrom(msg.sender, address(this), wethIn);\n\n    address vault = vaultManager.vault(vaultId);\n\n\t\treturn _addLiquidityAndLock(vaultId, vault, minTokenIn, minWethIn, wethIn, to);\n\t}\n\n  function unlockAndRemoveLiquidityETH(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 minTokenOut,\n    uint256 minEthOut,\n    address to\n  ) external override returns (uint256, uint256) {\n    IVaultManager _vaultManager = vaultManager;\n    if (to == address(0) || to == address(this)) revert InvalidDestination();\n    if (!_vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n    address vault = _vaultManager.vault(vaultId);\n\n    lpStaking.claimRewardsTo(vaultId, to);\n    lpStaking.withdrawTo(vaultId, amount, address(this));\n\n    (uint256 amountToken, uint256 amountEth) = router.removeLiquidityETH(\n      vault,\n      amount,\n      minTokenOut,\n      minEthOut,\n      to,\n      block.timestamp\n    );\n\n    return (amountToken, amountEth);\n  }\n\n  function unlockAndRemoveLiquidityWETH(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 minTokenOut,\n    uint256 minEthOut,\n    address to\n  ) external override returns (uint256, uint256) {\n    IVaultManager _vaultManager = vaultManager;\n    if (to == address(0) || to == address(this)) revert InvalidDestination();\n    if (!_vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n    address vault = _vaultManager.vault(vaultId);\n\n    lpStaking.claimRewardsTo(vaultId, to);\n    lpStaking.withdrawTo(vaultId, amount, address(this));\n\n    (uint256 amountToken, uint256 amountWeth) = router.removeLiquidity(\n      vault,\n      address(WETH),\n      amount,\n      minTokenOut,\n      minEthOut,\n      to,\n      block.timestamp\n    );\n\n    return (amountToken, amountWeth);\n  }\n\n\tfunction _addLiquidityAndLock(\n\t\tuint256 vaultId,\n    address vault,\n    uint256 minTokenIn,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n\t) internal returns (uint256, uint256, uint256) {\n\t\tif (!vaultManager.excludedFromFees(address(this))) revert NotExcluded();\n\n\t\t// Provide liquidity.\n    IERC20Upgradeable(vault).safeApprove(address(router), minTokenIn);\n\n\t\t(uint256 amountToken, uint256 amountEth, uint256 liquidity) = router.addLiquidity(\n      vault,\n      address(WETH),\n      minTokenIn,\n      wethIn,\n      minTokenIn,\n      minWethIn,\n      address(this),\n      block.timestamp\n    );\n\n\t\t// Stake in LP rewards contract\n    address lpToken = _pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).safeApprove(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n\n\t\tuint256 remaining = minTokenIn-amountToken;\n    if (remaining != 0) {\n      IERC20Upgradeable(vault).safeTransfer(to, remaining);\n    }\n\n\t\tuint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, to, minTokenIn, liquidity, lockEndTime);\n    return (amountToken, amountEth, liquidity);\n\t}\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function _pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = _sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      router.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    if (tokenA == tokenB) revert IdenticalAddress();\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    if (token0 == address(0)) revert ZeroAddress();\n  }\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/contracts/interfaces/ILPStakingZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IWETH.sol\";\nimport \"./ILPStaking.sol\";\nimport \"./IVaultManager.sol\";\nimport \"./IUniswapV2Router.sol\";\n\ninterface ILPStakingZap {\n    function WETH() external returns(IWETH);\n\n    function vaultManager() external returns(IVaultManager);\n\n    function router() external returns(IUniswapV2Router);\n\n    function lpStaking() external returns(ILPStaking);\n\n    function lpLockTime() external returns(uint256);\n\n    function assignLPStakingContract() external;\n\n    function rescue(address token) external;\n\n    function setLPLockTime(uint256 _lpLockTime) external;\n\n    function stakeLiquidityETH(\n\t\tuint256 vaultId,\n        uint256 minTokenIn,\n        uint256 wethIn,\n        address to\n\t) external payable returns (uint256, uint256, uint256);\n\n    function stakeLiquidityWETH(\n\t\tuint256 vaultId,\n        uint256 minTokenIn,\n        uint256 minWethIn,\n        uint256 wethIn,\n        address to\n\t) external returns (uint256, uint256, uint256);\n\n    function unlockAndRemoveLiquidityETH(\n        uint256 vaultId,\n        uint256 amount,\n        uint256 minTokenOut,\n        uint256 minEthOut,\n        address to\n    ) external returns (uint256, uint256);\n\n    function unlockAndRemoveLiquidityWETH(\n        uint256 vaultId,\n        uint256 amount,\n        uint256 minTokenOut,\n        uint256 minEthOut,\n        address to\n    ) external returns (uint256, uint256);\n\n    event UserStaked(uint256 indexed vaultId, address indexed sender, uint256 count, uint256 lpBalance, uint256 timelockUntil);\n    event LPLockTimeUpdated(uint256 oldLockTime, uint256 newLockTime);\n\n    error CallFailed();\n    error IdenticalAddress();\n    error InvalidDestination();\n    error LockTooLong();\n    error NotExcluded();\n    error NotZeroAddress();\n    error OnlyWETH();\n    error ZeroAddress();\n}\n"
    },
    "src/contracts/interfaces/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n}"
    },
    "src/contracts/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address, uint256) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "src/contracts/mocks/ERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract MockERC20Upgradeable is ERC20Upgradeable {\n    function __MockERC20Upgradeable_init(string calldata _name, string calldata _symbol) external initializer {\n        __ERC20_init(_name, _symbol);\n    }\n\n    function mint(address to, uint256 amount) external payable {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external payable {\n        _burn(from, amount);\n    }\n}"
    },
    "src/contracts/proxy/MultiProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IAdminUpgradeabilityProxy.sol\";\n\ncontract MultiProxyController is Ownable {\n    struct Proxy {\n        bytes32 name;\n        IAdminUpgradeabilityProxy proxy;\n        uint index;\n        bool isValue;\n    }\n\n    mapping(bytes32 => Proxy) public proxyMap;\n    bytes32[] public proxyKeys;\n\n    address public deployer;\n\n    event ProxyUpdated(bytes32 key, address proxy);\n    event ProxyRemoved(bytes32 key);\n    event ProxyAdminChanged(bytes32 key, address newAdmin);\n\n    constructor(bytes32[] memory _keys, address[] memory _proxies, address _deployer) Ownable() {\n        deployer = _deployer;\n        uint256 length = _proxies.length;\n        require(_keys.length == length, \"Not equal length\");\n        for (uint256 i; i < length;) {\n            addProxy(_keys[i], _proxies[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // Proxy Gov\n\n    function upgradeProxyTo(bytes32 key, address newImpl) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        proxyMap[key].proxy.upgradeTo(newImpl);\n    }\n\n    function changeProxyAdmin(bytes32 key, address newAdmin) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        proxyMap[key].proxy.changeAdmin(newAdmin);\n        emit ProxyAdminChanged(key, newAdmin);\n    }\n\n    // MultiProxyController Gov\n\n    function changeDeployer(address _deployer) external onlyOwner {\n        deployer = _deployer;\n    }\n\n    function deployerUpdateProxy(bytes32 key, address proxy) public {\n        require(msg.sender == deployer, \"Not deployer\");\n        if (proxyMap[key].isValue) {\n            _changeProxy(key, proxy);\n        } else {\n            _addProxy(key, proxy);\n        }\n    }\n\n    function _changeProxy(bytes32 key, address proxyAddress) private {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n\n        proxyMap[key].proxy = IAdminUpgradeabilityProxy(proxyAddress);\n    }\n\n    function changeProxy(bytes32 key, address proxyAddress) public onlyOwner {\n        _changeProxy(key, proxyAddress);\n    }\n\n    function changeProxyKey(bytes32 oldKey, bytes32 newKey) public onlyOwner {\n        require(proxyMap[oldKey].isValue, \"Doesn't exist\");\n\n        Proxy memory proxy = proxyMap[oldKey];\n\n        proxyMap[newKey] = proxy;\n        proxyKeys[proxy.index] = newKey;\n        delete proxyMap[oldKey];\n    }\n\n    function _addProxy(bytes32 key, address proxyAddress) private {\n        require(!proxyMap[key].isValue, \"Exists\");\n\n        IAdminUpgradeabilityProxy proxyContract = IAdminUpgradeabilityProxy(proxyAddress);\n        proxyKeys.push(key);\n        Proxy memory newProxy = Proxy(key, proxyContract, proxyKeys.length - 1, true);\n        proxyMap[key] = newProxy;\n        emit ProxyUpdated(key, proxyAddress);\n    }\n\n    function addProxy(bytes32 key, address proxyAddress) public onlyOwner {\n        _addProxy(key, proxyAddress);\n    }\n\n    function removeProxy(bytes32 key) public onlyOwner {\n        require(proxyMap[key].isValue, \"Doesn't exist\");\n        bytes32[] storage keys = proxyKeys;\n        Proxy memory proxy = proxyMap[key];\n\n        proxyMap[keys[keys.length - 1]].index = proxy.index;\n\n        keys[proxy.index] = keys[keys.length - 1];\n        keys.pop();\n\n        delete proxyMap[key];\n\n        emit ProxyRemoved(key);\n    }\n\n    function getName(bytes32 key) public view returns (bytes32) {\n        return proxyMap[key].name;\n    }\n\n    function getAdmin(bytes32 key) public view returns (address) {\n        return proxyMap[key].proxy.admin();\n    }\n\n    function getImpl(bytes32 key) public view returns(address) {\n        return proxyMap[key].proxy.implementation();\n    }\n\n    // Bulk\n\n    function changeAllAdmins(address newAdmin) external onlyOwner {\n        uint256 length = proxyKeys.length;\n        for (uint256 i; i < length;) {\n            changeProxyAdmin(proxyKeys[i], newAdmin);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getAllProxiesInfo() public view returns (bytes32[] memory) {\n        uint256 length = proxyKeys.length;\n        bytes32[] memory proxyInfos = new bytes32[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = proxyKeys[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n\n    function getAllProxies() external view returns (address[] memory) {\n        uint256 length = proxyKeys.length;\n        address[] memory proxyInfos = new address[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = address(proxyMap[proxyKeys[i]].proxy);\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n\n    function getAllImpls() external view returns (address[] memory) {\n        uint256 length = proxyKeys.length;\n        address[] memory proxyInfos = new address[](length);\n        for (uint256 i; i < length;) {\n            proxyInfos[i] = address(proxyMap[proxyKeys[i]].proxy.implementation());\n            unchecked {\n                ++i;\n            }\n        }\n        return proxyInfos;\n    }\n}\n"
    },
    "src/contracts/interfaces/IAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAdminUpgradeabilityProxy {\n    // Read functions.\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    // Write functions.\n    function changeAdmin(address newAdmin) external;\n\n    function upgradeTo(address newImplementation) external;\n}"
    },
    "src/contracts/mocks/NFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract SimpleMockNFT is ERC721, Ownable {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() ERC721(\"TestName\", \"TEST\") {\n        _tokenIdCounter.increment();\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n}\n\ncontract StandardMockNFT is ERC721, Ownable {\n\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    string private baseURI;\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        _tokenIdCounter.increment();\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\n        baseURI = _newBaseURI;\n    }\n}\n\ncontract NoURIMockNFT is Ownable {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function mint(address _to, uint256 _id) external {\n        _mint(_to, _id);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = NoURIMockNFT.ownerOf(tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(NoURIMockNFT.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(NoURIMockNFT.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/contracts/mocks/WETH.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice An implementation of Wrapped Ether. \n/// @author Anderson Singh. \ncontract WETH is ERC20 {\n\n    constructor(uint256 _wethAmount) ERC20(\"Wrapped Ether\", \"WETH\") {\n        _mint(msg.sender, _wethAmount);\n    }\n\n    /// @dev mint tokens for sender based on amount of ether sent. \n    function deposit() external payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    /// @dev withdraw ether based on requested amount and user balance. \n    function withdraw(uint _amount) external {\n        require(balanceOf(msg.sender) >= _amount, \"insufficient balance.\");\n        _burn(msg.sender, _amount);\n        payable(msg.sender).transfer(_amount);\n    }\n}"
    },
    "src/contracts/mocks/ERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Mock1155 is ERC1155 {\n    constructor() ERC1155(\"https://renaissancelab.art/token/\") {\n    }\n\n    function mint(address _to, uint256 _id, uint256 _amount) external {\n        _mint(_to, _id, _amount, \"\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}