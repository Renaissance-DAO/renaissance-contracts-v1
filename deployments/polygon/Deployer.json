{
  "address": "0xfB5cab41b4e92686a18a5ED63f0c3ceB6ebA2d6C",
  "abi": [
    {
      "inputs": [],
      "name": "NoController",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "identifier",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "logic",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        }
      ],
      "name": "ProxyDeployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FEE_DISTRIBUTOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FNFT_COLLECTION_FACTORY",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "INVENTORY_STAKING",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LP_STAKING",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STAKING_TOKEN_PROVIDER",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_MANAGER",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_fnftCollection",
          "type": "address"
        }
      ],
      "name": "deployFNFTCollectionFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "fnftCollectionFactory",
          "type": "address"
        }
      ],
      "name": "deployFNFTStaking",
      "outputs": [
        {
          "internalType": "address",
          "name": "fnftStaking",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "lpStaking",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "treasury",
          "type": "address"
        }
      ],
      "name": "deployFeeDistributor",
      "outputs": [
        {
          "internalType": "address",
          "name": "feeDistributor",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stakingTokenProvider",
          "type": "address"
        }
      ],
      "name": "deployLPStaking",
      "outputs": [
        {
          "internalType": "address",
          "name": "lpStaking",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "uniswapV2Factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "defaultPairedToken",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "defaultPrefix",
          "type": "string"
        }
      ],
      "name": "deployStakingTokenProvider",
      "outputs": [
        {
          "internalType": "address",
          "name": "stakingTokenProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_weth",
          "type": "address"
        }
      ],
      "name": "deployVaultManager",
      "outputs": [
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxyController",
      "outputs": [
        {
          "internalType": "contract IMultiProxyController",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_proxyController",
          "type": "address"
        }
      ],
      "name": "setProxyController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xd6365e638c8e7623d146f797f6738917575e36fcf0998af0f308916c8dcf7c51",
  "receipt": {
    "to": null,
    "from": "0xB249c8Bbb7D1e8833c3cd9dd9Ebe6aCE798a9D8C",
    "contractAddress": "0xfB5cab41b4e92686a18a5ED63f0c3ceB6ebA2d6C",
    "transactionIndex": 1,
    "gasUsed": "1707959",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000008000000000000000000000000000000100000000000000000000000000800001000000000000000100000000000000000000020000000000000000000800000000000000000080080000000000400000000000000400000000000000000000004000000000000000000000000000200000000000000000000000000000000000000000000400000000000200004000000000010000000001000000000000000000000000000000100000000020000000000000800000000000000000000000000000000000000000000000100008",
    "blockHash": "0xbaae8f0a4bdc1cc732c451103e4538208c84e28607bd6e90d3483efd02e171db",
    "transactionHash": "0xd6365e638c8e7623d146f797f6738917575e36fcf0998af0f308916c8dcf7c51",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 31738048,
        "transactionHash": "0xd6365e638c8e7623d146f797f6738917575e36fcf0998af0f308916c8dcf7c51",
        "address": "0xfB5cab41b4e92686a18a5ED63f0c3ceB6ebA2d6C",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000b249c8bbb7d1e8833c3cd9dd9ebe6ace798a9d8c"
        ],
        "data": "0x",
        "logIndex": 2,
        "blockHash": "0xbaae8f0a4bdc1cc732c451103e4538208c84e28607bd6e90d3483efd02e171db"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 31738048,
        "transactionHash": "0xd6365e638c8e7623d146f797f6738917575e36fcf0998af0f308916c8dcf7c51",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000b249c8bbb7d1e8833c3cd9dd9ebe6ace798a9d8c",
          "0x0000000000000000000000002a998cc0bb43dc510e523fe33c8f1c04bf607a1e"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000bccfa7569bd4f5a00000000000000000000000000000000000000000000000318e3a63ce0f9a950000000000000000000000000000000000000000000002a44a6dc3dde5f442b170000000000000000000000000000000000000000000000030d16abc7773c59f6000000000000000000000000000000000000000000002a44b2a93853c9017a71",
        "logIndex": 3,
        "blockHash": "0xbaae8f0a4bdc1cc732c451103e4538208c84e28607bd6e90d3483efd02e171db"
      }
    ],
    "blockNumber": 31738048,
    "cumulativeGasUsed": "1728959",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf0ff9e6b7fc2e915dfac7a0da096a36",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NoController\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DISTRIBUTOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FNFT_COLLECTION_FACTORY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVENTORY_STAKING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_STAKING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_TOKEN_PROVIDER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fnftCollection\",\"type\":\"address\"}],\"name\":\"deployFNFTCollectionFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fnftCollectionFactory\",\"type\":\"address\"}],\"name\":\"deployFNFTStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fnftStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"deployFeeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeDistributor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingTokenProvider\",\"type\":\"address\"}],\"name\":\"deployLPStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lpStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapV2Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultPairedToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"defaultPrefix\",\"type\":\"string\"}],\"name\":\"deployStakingTokenProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakingTokenProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"deployVaultManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyController\",\"outputs\":[{\"internalType\":\"contract IMultiProxyController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyController\",\"type\":\"address\"}],\"name\":\"setProxyController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"deployFNFTCollectionFactory(address,address,address)\":{\"params\":{\"_logic\":\"the implementation\",\"_vaultManager\":\"variable needed for FNFTCollectionFactory\"}},\"deployFNFTStaking(address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployFeeDistributor(address,address,address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployLPStaking(address,address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployStakingTokenProvider(address,address,address,string)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployVaultManager(address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deployFNFTCollectionFactory(address,address,address)\":{\"notice\":\"the function to deploy FNFTCollectionFactory\"},\"deployFNFTStaking(address,address)\":{\"notice\":\"the function to deploy FNFTStaking\"},\"deployFeeDistributor(address,address,address,address)\":{\"notice\":\"the function to deploy FeeDistributor\"},\"deployLPStaking(address,address,address)\":{\"notice\":\"the function to deploy LPStaking\"},\"deployStakingTokenProvider(address,address,address,string)\":{\"notice\":\"the function to deploy StakingTokenProvider\"},\"deployVaultManager(address,address)\":{\"notice\":\"the function to deploy FNFTCollectionFactory\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/proxy/Deployer.sol\":\"Deployer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x652fee292f698d8dba81bf287cb71f1682f6483b67ebe601a5f7387dcfc30b34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\",\"keccak256\":\"0xe26a9d6acdb88e0b83c7659f9c809847da6996528dc8a4e6f0ed14e395dd1657\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe73087c5001a37cf7186b3709377c7ceb01a0d38fb908723d1464cea66b4958c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashBorrowerUpgradeable {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0x51e5fea61116bd84d45c4bbb0d7923ab0ab182e923b0187667f146327d6ef496\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x45fe5b6e09537c84248325b6cb3595aed7752b07425dfe136351234f2d8130dd\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x041af89e5e60b74e1203d5a34614c9de379726f52ecb8cf064cab78b9fdcdf9d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x8cc03c5ac17e8a7396e487cda41fc1f1dfdb91db7d528e6da84bee3b6dd7e167\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3e26a49d2fa5ef8338b8a9467c91e54f417cb07e849b1cc0f4ebc4d2a147938e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\",\"keccak256\":\"0xebe3f8a59f0f1c96344a05edb984ef666ee4207e993cca99af3808f1de8771b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"src/contracts/FNFTCollectionFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IFNFTCollectionFactory.sol\\\";\\nimport \\\"./interfaces/IOwnable.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./proxy/BeaconProxy.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\n// Authors: @0xKiwi_ and @alexgausman.\\n\\ncontract FNFTCollectionFactory is\\n    IFNFTCollectionFactory,\\n    Pausable,\\n    BeaconUpgradeable\\n{\\n    mapping(uint256 => VaultFees) private _vaultFees;\\n\\n    uint64 public override factoryMintFee;\\n    uint64 public override factoryRandomRedeemFee;\\n    uint64 public override factoryRandomSwapFee;\\n    uint64 public override factoryTargetRedeemFee;\\n\\n    IVaultManager public override vaultManager;\\n    uint64 public override factoryTargetSwapFee;\\n\\n    address public override eligibilityManager;\\n    uint256 public override flashLoanFee;\\n\\n    /// @notice the maximum auction length\\n    uint256 public override maxAuctionLength;\\n\\n    /// @notice the minimum auction length\\n    uint256 public override minAuctionLength;\\n\\n    /// @notice the % bid increase required for a new bid\\n    uint256 public override minBidIncrease;\\n\\n    function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external override initializer {\\n        if (_vaultManager == address(0)) revert ZeroAddress();\\n        if (_fnftCollection == address(0)) revert ZeroAddress();\\n        __Pausable_init();\\n        __BeaconUpgradeable__init(_fnftCollection);\\n        vaultManager = IVaultManager(_vaultManager);\\n        factoryMintFee = uint64(0.1 ether);\\n        factoryRandomRedeemFee = uint64(0.05 ether);\\n        factoryTargetRedeemFee = uint64(0.1 ether);\\n        factoryRandomSwapFee = uint64(0.05 ether);\\n        factoryTargetSwapFee = uint64(0.1 ether);\\n        maxAuctionLength = 2 weeks;\\n        minAuctionLength = 3 days;\\n        minBidIncrease = 500; // 5%\\n    }\\n\\n    function createVault(\\n        address _assetAddress,\\n        bool is1155,\\n        bool allowAllItems,\\n        string memory _name,\\n        string memory _symbol\\n    ) external virtual override returns (address) {\\n        onlyOwnerIfPaused(0);\\n        if (childImplementation() == address(0)) revert ZeroAddress();\\n        IVaultManager _vaultManager = vaultManager;\\n        address fnftCollection = _deployVault(_name, _symbol, _assetAddress, is1155, allowAllItems);\\n        uint vaultId = _vaultManager.addVault(fnftCollection);\\n        emit VaultCreated(vaultId, msg.sender, fnftCollection, _assetAddress, _name, _symbol);\\n        return fnftCollection;\\n    }\\n\\n    function setEligibilityManager(address _eligibilityManager) external virtual override onlyOwner {\\n        emit EligibilityManagerUpdated(eligibilityManager, _eligibilityManager);\\n        eligibilityManager = _eligibilityManager;\\n    }\\n\\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\\n        VaultFees memory fees = _vaultFees[vaultId];\\n        if (fees.active) {\\n            return (\\n                uint256(fees.mintFee),\\n                uint256(fees.randomRedeemFee),\\n                uint256(fees.targetRedeemFee),\\n                uint256(fees.randomSwapFee),\\n                uint256(fees.targetSwapFee)\\n            );\\n        }\\n\\n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\\n    }\\n\\n    function disableVaultFees(uint256 vaultId) public virtual override {\\n        if (msg.sender != owner()) {\\n            address vaultAddr = vaultManager.vault(vaultId);\\n            if (msg.sender != vaultAddr) revert NotVault();\\n        }\\n        delete _vaultFees[vaultId];\\n        emit VaultFeesDisabled(vaultId);\\n    }\\n\\n    function setFactoryFees(\\n        uint256 _factoryMintFee,\\n        uint256 _factoryRandomRedeemFee,\\n        uint256 _factoryTargetRedeemFee,\\n        uint256 _factoryRandomSwapFee,\\n        uint256 _factoryTargetSwapFee,\\n        uint256 _flashLoanFee\\n    ) public virtual override onlyOwner {\\n        if (_factoryMintFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryRandomRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryTargetRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryRandomSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryTargetSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_flashLoanFee > 500) revert FeeTooHigh();\\n\\n        factoryMintFee = uint64(_factoryMintFee);\\n        factoryRandomRedeemFee = uint64(_factoryRandomRedeemFee);\\n        factoryTargetRedeemFee = uint64(_factoryTargetRedeemFee);\\n        factoryRandomSwapFee = uint64(_factoryRandomSwapFee);\\n        factoryTargetSwapFee = uint64(_factoryTargetSwapFee);\\n        flashLoanFee = _flashLoanFee;\\n\\n        emit FactoryFeesUpdated(\\n            _factoryMintFee,\\n            _factoryRandomRedeemFee,\\n            _factoryTargetRedeemFee,\\n            _factoryRandomSwapFee,\\n            _factoryTargetSwapFee,\\n            _flashLoanFee\\n        );\\n    }\\n\\n    function setFactoryThresholds(\\n        uint256 _maxAuctionLength,\\n        uint256 _minAuctionLength,\\n        uint256 _minBidIncrease\\n    ) public virtual override onlyOwner {\\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\\n\\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\\n\\n        maxAuctionLength = _maxAuctionLength;\\n        minAuctionLength = _minAuctionLength;\\n        minBidIncrease = _minBidIncrease;\\n\\n        emit FactoryThresholdsUpdated(_maxAuctionLength, _minAuctionLength, _minBidIncrease);\\n    }\\n\\n    function setVaultFees(\\n        uint256 vaultId,\\n        uint256 _mintFee,\\n        uint256 _randomRedeemFee,\\n        uint256 _targetRedeemFee,\\n        uint256 _randomSwapFee,\\n        uint256 _targetSwapFee\\n    ) public virtual override {\\n        if (msg.sender != owner()) {\\n            address vaultAddr = vaultManager.vault(vaultId);\\n            if (msg.sender != vaultAddr) revert NotVault();\\n        }\\n        if (_mintFee > 0.5 ether) revert FeeTooHigh();\\n        if (_randomRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_targetRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_randomSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_targetSwapFee > 0.5 ether) revert FeeTooHigh();\\n\\n        _vaultFees[vaultId] = VaultFees(\\n            true,\\n            uint64(_mintFee),\\n            uint64(_randomRedeemFee),\\n            uint64(_targetRedeemFee),\\n            uint64(_randomSwapFee),\\n            uint64(_targetSwapFee)\\n        );\\n        emit VaultFeesUpdated(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\\n    }\\n\\n    /// @dev 0x042f186c == FNFTCollection.__FNFTCollection_init.selector\\n    function _deployVault(\\n        string memory name,\\n        string memory symbol,\\n        address _assetAddress,\\n        bool is1155,\\n        bool allowAllItems\\n    ) internal returns (address) {\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            0x042f186c,\\n            name,\\n            symbol,\\n            msg.sender,\\n            _assetAddress,\\n            is1155,\\n            allowAllItems\\n        );\\n\\n        address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\\n\\n        // Owner for administrative functions.\\n        IOwnable(newBeaconProxy).transferOwnership(owner());\\n\\n        return newBeaconProxy;\\n    }\\n}\",\"keccak256\":\"0x9902ac132f86b110319f33a1c5f154e7d58852e4c0bf5a2c249feb2f6a2fb3dc\",\"license\":\"MIT\"},\"src/contracts/FNFTStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./interfaces/IFNFTCollection.sol\\\";\\nimport \\\"./interfaces/IFNFTStaking.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\nimport \\\"./proxy/Create2BeaconProxy.sol\\\";\\nimport \\\"./token/FNFTStakingXTokenUpgradeable.sol\\\";\\nimport \\\"./interfaces/ITimelockExcludeList.sol\\\";\\n\\n// Author: 0xKiwi.\\n\\n// Pausing codes for inventory staking are:\\n// 10: Deposit\\n\\ncontract FNFTStaking is IFNFTStaking, Pausable, BeaconUpgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    // Small locktime to prevent flash deposits.\\n    uint256 internal constant DEFAULT_LOCKTIME = 2;\\n    bytes internal constant BEACON_CODE = type(Create2BeaconProxy).creationCode;\\n\\n    IVaultManager public override vaultManager;\\n    ITimelockExcludeList public override timelockExcludeList;\\n\\n    uint256 public override inventoryLockTimeErc20;\\n\\n    function __FNFTStaking_init(address _vaultManager) external virtual override initializer {\\n        __Ownable_init();\\n        vaultManager = IVaultManager(_vaultManager);\\n        address xTokenImpl = address(new FNFTStakingXTokenUpgradeable());\\n        __BeaconUpgradeable__init(xTokenImpl);\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\\n        _;\\n    }\\n\\n    function balanceOf(uint256 vaultId, address who) external view override returns (uint256) {\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\\n        return xToken.balanceOf(who);\\n    }\\n\\n    // Enter staking. Staking, get minted shares and\\n    // locks base tokens and mints xTokens.\\n    function deposit(uint256 vaultId, uint256 _amount) external virtual override {\\n        onlyOwnerIfPaused(10);\\n\\n        uint256 timelockTime = isAddressTimelockExcluded(msg.sender, vaultId) ? 0 : inventoryLockTimeErc20;\\n\\n        (IERC20Upgradeable baseToken, FNFTStakingXTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, timelockTime);\\n        // Lock the base token in the xtoken contract\\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\\n        emit BaseTokenDeposited(vaultId, _amount, xTokensMinted, timelockTime, msg.sender);\\n    }\\n\\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) public view override returns (bool) {\\n        if (address(timelockExcludeList) == address(0)) {\\n            return false;\\n        } else {\\n            return timelockExcludeList.isExcluded(addr, vaultId);\\n        }\\n    }\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address deployedXToken = xTokenAddr(address(baseToken));\\n\\n        // Don't distribute rewards unless there are people to distribute to.\\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\\n        if (!_isContract(deployedXToken) || FNFTStakingXTokenUpgradeable(deployedXToken).totalSupply() == 0) {\\n            return false;\\n        }\\n        // We \\\"pull\\\" to the dividend tokens so the fee distributor only needs to approve this contract.\\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\\n        emit FeesReceived(vaultId, amount, deployedXToken);\\n        return true;\\n    }\\n\\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external override onlyOwner {\\n        if (_inventoryLockTimeErc20 > 14 days) revert LockTooLong();\\n        emit InventoryLockTimeErc20Updated(inventoryLockTimeErc20, _inventoryLockTimeErc20);\\n        inventoryLockTimeErc20 = _inventoryLockTimeErc20;\\n    }\\n\\n    // TODO: timelock exclude list is not yet implemented\\n    function setTimelockExcludeList(address _timelockExcludeList) external override onlyOwner {\\n        emit TimelockExcludeListUpdated(address(timelockExcludeList), _timelockExcludeList);\\n        timelockExcludeList = ITimelockExcludeList(_timelockExcludeList);\\n    }\\n\\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\\n        onlyOwnerIfPaused(10);\\n        if (msg.sender != vaultManager.zapContract()) revert NotZapContract();\\n        // important for math that staking zap is excluded from fees\\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\\n\\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\\n        emit BaseTokenDeposited(vaultId, amount, xTokensMinted, timelockLength, to);\\n        return xTokensMinted;\\n    }\\n\\n    function timelockUntil(uint256 vaultId, address who) external view override returns (uint256) {\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\\n        return xToken.timelockUntil(who);\\n    }\\n\\n    // Leave the bar. Claim back your tokens.\\n    // Unlocks the staked + gained tokens and burns xTokens.\\n    function withdraw(uint256 vaultId, uint256 _share) external virtual override {\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\\n\\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\\n        emit XTokenWithdrawn(vaultId, baseTokensRedeemed, _share, msg.sender);\\n    }\\n\\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\\n        if (!_isContract(address(xToken))) revert XTokenNotDeployed();\\n\\n        uint256 multiplier = 10 ** 18;\\n        return xToken.totalSupply() > 0\\n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply()\\n            : multiplier;\\n    }\\n\\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address deployedXToken = xTokenAddr(address(baseToken));\\n\\n        if (_isContract(deployedXToken)) {\\n            return;\\n        }\\n\\n        address xToken = _deployXToken(baseToken);\\n        emit StakingPoolCreated(vaultId, xToken, baseToken);\\n    }\\n\\n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address xToken = xTokenAddr(baseToken);\\n        if (!_isContract(xToken)) revert XTokenNotDeployed();\\n        return xToken;\\n    }\\n\\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\\n        return tokenAddr;\\n    }\\n\\n    function _deployXToken(address baseToken) internal returns (address) {\\n        string memory symbol = IERC20Metadata(baseToken).symbol();\\n        symbol = string(abi.encodePacked(\\\"x\\\", symbol));\\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\\n        address deployedXToken = Create2.deploy(0, salt, BEACON_CODE);\\n        FNFTStakingXTokenUpgradeable(deployedXToken).__FNFTStakingXToken_init(baseToken, symbol, symbol);\\n        return deployedXToken;\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size != 0;\\n    }\\n\\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, FNFTStakingXTokenUpgradeable, uint256) {\\n        deployXTokenForVault(vaultId);\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable((xTokenAddr(address(baseToken))));\\n\\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\\n        return (baseToken, xToken, xTokensMinted);\\n    }\\n}\\n\",\"keccak256\":\"0xe8a3fbf869c622a9e8a11cd62627aaeafe35fe4e4133bdfdc6b4e71b126b6ffc\",\"license\":\"MIT\"},\"src/contracts/FeeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport \\\"./interfaces/IFNFTStaking.sol\\\";\\nimport \\\"./interfaces/IFeeDistributor.sol\\\";\\nimport \\\"./interfaces/ILPStaking.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuardUpgradeable, Pausable {\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  FeeReceiver[] public override feeReceivers;\\n\\n  IFNFTStaking public override fnftStaking;\\n  ILPStaking public override lpStaking;\\n  IVaultManager public override vaultManager;\\n  address public override treasury;\\n\\n  // Total allocation points per vault.\\n  uint256 public override allocTotal;\\n  bool public override distributionPaused;\\n\\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external override initializer {\\n    __Pausable_init();\\n\\n    vaultManager = IVaultManager(_vaultManager);\\n\\n    setTreasuryAddress(_treasury);\\n    setLPStakingAddress(_lpStaking);\\n\\n    _addReceiver(0.8 ether, _lpStaking, true);\\n  }\\n\\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\\n    _addReceiver(_allocPoint, _receiver, _isContract);\\n  }\\n\\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\\n    IVaultManager _vaultManager = vaultManager;\\n    if (address(_vaultManager) == address(0)) revert ZeroAddress();\\n    address _vault = _vaultManager.vault(vaultId);\\n\\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n\\n    if (distributionPaused || allocTotal == 0) {\\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\\n      return;\\n    }\\n\\n    uint256 length = feeReceivers.length;\\n    uint256 leftover;\\n    for (uint256 i; i < length;) {\\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\\n      if (!complete) {\\n        uint256 remaining = IERC20Upgradeable(_vault).allowance(address(this), _feeReceiver.receiver);\\n        IERC20Upgradeable(_vault).safeApprove(_feeReceiver.receiver, 0);\\n        leftover = remaining;\\n      } else {\\n        leftover = 0;\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    if (leftover != 0) {\\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\\n    }\\n  }\\n\\n  function initializeVaultReceivers(uint256 _vaultId) external override {\\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\\n    lpStaking.addPoolForVault(_vaultId);\\n    IFNFTStaking _inventoryStaking = fnftStaking;\\n    if (address(_inventoryStaking) != address(0))\\n      _inventoryStaking.deployXTokenForVault(_vaultId);\\n  }\\n\\n  function pauseFeeDistribution(bool _pause) external override onlyOwner {\\n    distributionPaused = _pause;\\n    emit DistributionPaused(_pause);\\n  }\\n\\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\\n    uint256 arrLength = feeReceivers.length;\\n    if (_receiverIdx >= arrLength) revert OutOfBounds();\\n    emit FeeReceiverRemoved(feeReceivers[_receiverIdx].receiver);\\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\\n    // Copy the last element to what is being removed and remove the last element.\\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\\n    feeReceivers.pop();\\n  }\\n\\n  function rescueTokens(address _address) external override onlyOwner {\\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\\n  }\\n\\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\\n    address oldReceiver = feeReceiver.receiver;\\n    feeReceiver.receiver = _address;\\n    feeReceiver.isContract = _isContract;\\n    emit FeeReceiverAddressUpdated(oldReceiver, _address);\\n  }\\n\\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\\n    if(_receiverIdx >= feeReceivers.length) revert OutOfBounds();\\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\\n    allocTotal -= feeReceiver.allocPoint;\\n    feeReceiver.allocPoint = _allocPoint;\\n    allocTotal += _allocPoint;\\n    emit FeeReceiverAllocUpdated(feeReceiver.receiver, _allocPoint);\\n  }\\n\\n  function setFNFTStakingAddress(address _inventoryStaking) public override onlyOwner {\\n    fnftStaking = IFNFTStaking(_inventoryStaking);\\n    emit FNFTStakingAddressUpdated(_inventoryStaking);\\n  }\\n\\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\\n    if (_lpStaking == address(0)) revert ZeroAddress();\\n    lpStaking = ILPStaking(_lpStaking);\\n    emit LPStakingAddressUpdated(_lpStaking);\\n  }\\n\\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\\n    if (_treasury == address(0)) revert ZeroAddress();\\n    treasury = _treasury;\\n    emit TreasuryAddressUpdated(_treasury);\\n  }\\n\\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\\n    feeReceivers.push(_feeReceiver);\\n    allocTotal += _allocPoint;\\n    emit FeeReceiverAdded(_receiver, _allocPoint);\\n  }\\n\\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\\n    if (_receiver.isContract) {\\n      IERC20Upgradeable(_vault).safeIncreaseAllowance(_receiver.receiver, amountToSend);\\n\\n      bytes memory payload = abi.encodeWithSelector(ILPStaking.receiveRewards.selector, _vaultId, amountToSend);\\n      (bool success, ) = address(_receiver.receiver).call(payload);\\n\\n      // If the allowance has not been spent, it means we can pass it forward to next.\\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\\n    } else {\\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\\n      return true;\\n    }\\n  }\\n}\",\"keccak256\":\"0xb3601396f7eda95e13d5dd49f632a1dde196911f31d15319e56b9b707ff73659\",\"license\":\"MIT\"},\"src/contracts/LPStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\n\\nimport \\\"./interfaces/ILPStaking.sol\\\";\\nimport \\\"./interfaces/IStakingTokenProvider.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./token/LPStakingXTokenUpgradeable.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\n// Pausing codes for LP staking are:\\n// 10: Deposit\\n\\ncontract LPStaking is ILPStaking, Pausable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    mapping(uint256 => StakingPool) public override vaultStakingInfo;\\n\\n    IStakingTokenProvider public override stakingTokenProvider;\\n    LPStakingXTokenUpgradeable public override lpStakingXToken;\\n    IVaultManager public override vaultManager;\\n\\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external override initializer {\\n        __Ownable_init();\\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\\n        if (address(lpStakingXToken) != address(0)) revert LPStakingXTokenAlreadySet();\\n        vaultManager = IVaultManager(_vaultManager);\\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\\n        lpStakingXToken = new LPStakingXTokenUpgradeable();\\n        lpStakingXToken.__LPStakingXToken_init(IERC20Upgradeable(address(0)), \\\"\\\", \\\"\\\");\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\\n        _;\\n    }\\n\\n    function addPoolForVault(uint256 vaultId) external override onlyAdmin {\\n        if (address(vaultManager) == address(0)) revert VaultManagerNotSet();\\n        if (vaultStakingInfo[vaultId].stakingToken != address(0)) revert PoolAlreadyExists();\\n        address _baseToken = vaultManager.vault(vaultId);\\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_baseToken);\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        vaultStakingInfo[vaultId] = pool;\\n        address newXToken = _deployDividendToken(pool);\\n        emit StakingPoolCreated(vaultId, newXToken, _baseToken);\\n    }\\n\\n    function deposit(uint256 vaultId, uint256 amount) external override {\\n        onlyOwnerIfPaused(10);\\n        // Check the pool in case its been updated.\\n        updatePoolForVault(vaultId);\\n\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n\\n        // If the user has an existing timelock, check if it is in the future.\\n        uint256 currentTimelock = _xToken.timelockUntil(msg.sender);\\n        if (currentTimelock > block.timestamp) {\\n            // Maintain the same timelock if they already have one.\\n            // We do this instead of patching in the token because\\n            // the reward distribution token contracts as currently deployed are not upgradeable.\\n            _xToken.timelockMint(msg.sender, amount, currentTimelock-block.timestamp);\\n        } else {\\n            // Timelock for 2 seconds if they don't already have a timelock to prevent flash loans.\\n            _xToken.timelockMint(msg.sender, amount, 2);\\n        }\\n\\n        emit LPDeposited(vaultId, amount, address(_xToken), msg.sender);\\n    }\\n\\n    function claimMultipleRewards(uint256[] calldata vaultIds) external override {\\n        uint256 length = vaultIds.length;\\n        for (uint256 i; i < length;) {\\n            claimRewardsTo(vaultIds[i], msg.sender);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function emergencyExit(address _stakingToken, address _baseToken) external override {\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        LPStakingXTokenUpgradeable dist = xToken(pool);\\n        if (!_isContract(address(dist))) revert NotAPool();\\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\\n    }\\n\\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external override {\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        LPStakingXTokenUpgradeable dist = xToken(pool);\\n        if (!_isContract(address(dist))) revert NotAPool();\\n        _claimRewards(pool, msg.sender);\\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\\n    }\\n\\n    function exit(uint256 vaultId) external override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, msg.sender);\\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\\n    }\\n\\n    function lockedLPBalance(uint256 vaultId, address who) external view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        if(block.timestamp > _xToken.timelockUntil(who)) {\\n            return 0;\\n        }\\n        return _xToken.balanceOf(who);\\n    }\\n\\n    function lockedUntil(uint256 vaultId, address who) external view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        return _xToken.timelockUntil(who);\\n    }\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external override onlyAdmin returns (bool) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) {\\n            // In case the pair is updated, but not yet\\n            return false;\\n        }\\n\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        // Don't distribute rewards unless there are people to distribute to.\\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\\n        if (!_isContract(address(_xToken)) || _xToken.totalSupply() == 0) {\\n            return false;\\n        }\\n        // We \\\"pull\\\" to the dividend tokens so the vault only needs to approve this contract.\\n        IERC20Upgradeable(pool.baseToken).safeTransferFrom(msg.sender, address(_xToken), amount);\\n        _xToken.distributeRewards(amount);\\n        emit FeesReceived(vaultId, amount, address(_xToken));\\n        return true;\\n    }\\n\\n    function xToken(uint256 vaultId) external view override returns (LPStakingXTokenUpgradeable) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) {\\n            return LPStakingXTokenUpgradeable(address(0));\\n        }\\n        return xToken(pool);\\n    }\\n\\n    function setStakingTokenProvider(address _stakingTokenProvider) external override onlyOwner {\\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\\n        emit StakingTokenProviderUpdated(address(stakingTokenProvider), _stakingTokenProvider);\\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\\n    }\\n\\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external override {\\n        if (timelockLength >= 2592000) revert TimelockTooLong();\\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\\n        onlyOwnerIfPaused(10);\\n        // Check the pool in case its been updated.\\n        updatePoolForVault(vaultId);\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\\n        xToken(pool).timelockMint(account, amount, timelockLength);\\n    }\\n\\n    // In case the provider changes, this lets the pool be updated. Anyone can call it.\\n    function updatePoolForVault(uint256 vaultId) public override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        // Not letting people use this function to create new pools.\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.baseToken);\\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.baseToken);\\n        vaultStakingInfo[vaultId] = newPool;\\n\\n        // If the pool is already deployed, ignore the update.\\n        address addr = address(xToken(newPool));\\n        if (_isContract(addr)) {\\n            return;\\n        }\\n        address newXToken = _deployDividendToken(newPool);\\n        emit StakingPoolUpdated(vaultId, newXToken);\\n    }\\n\\n    function updatePoolForVaults(uint256[] calldata vaultIds) external override {\\n        uint256 length = vaultIds.length;\\n        for (uint256 i; i < length;) {\\n            updatePoolForVault(vaultIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, to);\\n        _withdraw(pool, amount, to);\\n\\n        emit XTokenWithdrawn(vaultId, amount, address(xToken(pool)), to);\\n    }\\n\\n    function balanceOf(uint256 vaultId, address addr) public view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        if (!_isContract(address(_xToken))) revert NotAPool();\\n        return _xToken.balanceOf(addr);\\n    }\\n\\n    function claimRewardsTo(uint256 vaultId, address to) public override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, to);\\n    }\\n\\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\\n    function xToken(StakingPool memory pool) public view override returns (LPStakingXTokenUpgradeable) {\\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2) /* small nonce to change tokens */));\\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(lpStakingXToken), salt);\\n        return LPStakingXTokenUpgradeable(tokenAddr);\\n    }\\n\\n    function xTokenAddr(address stakedToken, address baseToken) public view override returns (address) {\\n        StakingPool memory pool = StakingPool(stakedToken, baseToken);\\n        return address(xToken(pool));\\n    }\\n\\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) public override onlyOwner {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        _xToken.burnFrom(from, amount);\\n        _xToken.mint(to, amount);\\n    }\\n\\n    function _claimRewards(StakingPool memory pool, address account) internal {\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        xToken(pool).withdrawReward(account);\\n    }\\n\\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\\n        // Changed to use new nonces.\\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2)));\\n        address _xToken = ClonesUpgradeable.cloneDeterministic(address(lpStakingXToken), salt);\\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.baseToken);\\n        LPStakingXTokenUpgradeable(_xToken).__LPStakingXToken_init(IERC20Upgradeable(pool.baseToken), name, name);\\n        return _xToken;\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        xToken(pool).burnFrom(account, amount);\\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(account, amount);\\n    }\\n}\",\"keccak256\":\"0xb5b05418e58e2f550369338465c69104b70bca23ed7cf0f3647def88fd022cec\",\"license\":\"MIT\"},\"src/contracts/StakingTokenProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n// Author: 0xKiwi.\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./interfaces/IStakingTokenProvider.sol\\\";\\n\\ncontract StakingTokenProvider is IStakingTokenProvider, OwnableUpgradeable {\\n  mapping(address => string) public override pairedPrefix;\\n  mapping(address => address) public override pairedToken;\\n\\n  address public override defaultPairedToken;\\n  address public override uniLikeExchange;\\n\\n  string public override defaultPrefix;\\n\\n  // This is an address provder to allow us to abstract out what liquidity\\n  // our vault tokens should be paired with.\\n  function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) public override initializer {\\n    __Ownable_init();\\n    if (_uniLikeExchange == address(0)) revert ZeroAddress();\\n    if (_defaultPairedtoken == address(0)) revert ZeroAddress();\\n    uniLikeExchange = _uniLikeExchange;\\n    defaultPairedToken = _defaultPairedtoken;\\n    defaultPrefix = _defaultPrefix;\\n  }\\n\\n  function nameForStakingToken(address _vaultToken) external view override returns (string memory) {\\n    string memory _pairedPrefix = pairedPrefix[_vaultToken];\\n    if (bytes(_pairedPrefix).length == 0) {\\n      _pairedPrefix = defaultPrefix;\\n    }\\n    address _pairedToken = pairedToken[_vaultToken];\\n    if (_pairedToken == address(0)) {\\n      _pairedToken = defaultPairedToken;\\n    }\\n\\n    string memory symbol1 = IERC20Metadata(_vaultToken).symbol();\\n    string memory symbol2 = IERC20Metadata(_pairedToken).symbol();\\n    return string(abi.encodePacked(_pairedPrefix, symbol1, symbol2));\\n  }\\n\\n  function pairForVaultToken(address _vaultToken, address _pairedToken) external view override returns (address) {\\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\\n  }\\n\\n  function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external override onlyOwner {\\n    emit DefaultPairedTokenUpdated(defaultPairedToken, _defaultPairedToken);\\n    defaultPairedToken = _defaultPairedToken;\\n    defaultPrefix = _defaultPrefix;\\n  }\\n\\n  function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external override onlyOwner {\\n    if (_newPairedToken == address(0)) revert ZeroAddress();\\n    emit PairedTokenForVaultUpdated(_vaultToken, pairedToken[_vaultToken], _newPairedToken);\\n    pairedToken[_vaultToken] = _newPairedToken;\\n    pairedPrefix[_vaultToken] = _newPrefix;\\n  }\\n\\n  function stakingTokenForVaultToken(address _vaultToken) external view override returns (address) {\\n    address _pairedToken = pairedToken[_vaultToken];\\n    if (_pairedToken == address(0)) {\\n      _pairedToken = defaultPairedToken;\\n    }\\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function _pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n      (address token0, address token1) = _sortTokens(tokenA, tokenB);\\n      pair = address(uint160(uint256(keccak256(abi.encodePacked(\\n              hex'ff',\\n              factory,\\n              keccak256(abi.encodePacked(token0, token1)),\\n              hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\\n      )))));\\n  }\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n      if (tokenA == tokenB) revert IdenticalAddress();\\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n      if (token0 == address(0)) revert ZeroAddress();\\n  }\\n}\",\"keccak256\":\"0x3c23d826b12b9ac5a1aa8e36d3641cbd95cb6d3f61a4b02a6ba64595fb084967\",\"license\":\"MIT\"},\"src/contracts/VaultManager.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./interfaces/IFeeDistributor.sol\\\";\\n\\ncontract VaultManager is\\n    OwnableUpgradeable,\\n    PausableUpgradeable,\\n    IVaultManager\\n{\\n    mapping(address => bool) public override excludedFromFees;\\n\\n    address[] public override vaults;\\n\\n    address public override feeDistributor;\\n\\n    /// @notice the address who receives auction fees\\n    address payable public override feeReceiver;\\n\\n    address public override fnftSingleFactory;\\n\\n    address public override fnftCollectionFactory;\\n\\n    address public override ifoFactory;\\n\\n    address public override priceOracle;\\n\\n    address public override zapContract;\\n\\n    address public override WETH;\\n\\n    function __VaultManager_init(address _weth) external override initializer {\\n        __Ownable_init();\\n        __Pausable_init();\\n        WETH = _weth;\\n        feeReceiver = payable(msg.sender);\\n    }\\n\\n    function addVault(address _fnft) external override returns (uint256 vaultId) {\\n        if (_fnft == address(0)) revert ZeroAddress();\\n        address _feeDistributor = feeDistributor;\\n        if (_feeDistributor == address(0)) revert ZeroAddress();\\n        if (msg.sender != fnftCollectionFactory && msg.sender != fnftSingleFactory) revert OnlyFactory();\\n        vaultId = vaults.length;\\n        vaults.push(_fnft);\\n        IFeeDistributor(_feeDistributor).initializeVaultReceivers(vaultId);\\n        emit VaultAdded(vaultId, _fnft);\\n    }\\n\\n    function numVaults() external view override returns (uint) {\\n        return vaults.length;\\n    }\\n\\n    function setFeeDistributor(address _feeDistributor) public override onlyOwner {\\n        if (_feeDistributor == address(0)) revert ZeroAddress();\\n        emit FeeDistributorUpdated(feeDistributor, _feeDistributor);\\n        feeDistributor = _feeDistributor;\\n    }\\n\\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\\n        if (_feeReceiver == address(0)) revert ZeroAddress();\\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\\n        feeReceiver = _feeReceiver;\\n    }\\n\\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external override onlyOwner {\\n        if (_fnftCollectionFactory == address(0)) revert ZeroAddress();\\n        emit FNFTCollectionFactoryUpdated(fnftCollectionFactory, _fnftCollectionFactory);\\n        fnftCollectionFactory = _fnftCollectionFactory;\\n    }\\n\\n    function setFNFTSingleFactory(address _fnftSingleFactory) external override onlyOwner {\\n        if (_fnftSingleFactory == address(0)) revert ZeroAddress();\\n        emit FNFTSingleFactoryUpdated(fnftSingleFactory, _fnftSingleFactory);\\n        fnftSingleFactory = _fnftSingleFactory;\\n    }\\n\\n    function setIFOFactory(address _ifoFactory) external override onlyOwner {\\n        emit IFOFactoryUpdated(ifoFactory, _ifoFactory);\\n        ifoFactory = _ifoFactory;\\n    }\\n\\n    function setPriceOracle(address _priceOracle) external override onlyOwner {\\n        emit PriceOracleUpdated(priceOracle, _priceOracle);\\n        priceOracle = _priceOracle;\\n    }\\n\\n    function setZapContract(address _zapContract) external override onlyOwner {\\n        if (_zapContract == address(0)) revert ZeroAddress();\\n        emit ZapContractUpdated(zapContract, _zapContract);\\n        zapContract = _zapContract;\\n    }\\n\\n    function togglePaused() external override onlyOwner {\\n        paused() ? _unpause() : _pause();\\n    }\\n\\n    function vault(uint256 vaultId) external view override returns (address) {\\n        return vaults[vaultId];\\n    }\\n\\n    function setFeeExclusion(address _address, bool _excluded) public override onlyOwner {\\n        emit FeeExclusionUpdated(_address, _excluded);\\n        excludedFromFees[_address] = _excluded;\\n    }\\n}\\n\",\"keccak256\":\"0xb7be5f9246f0910db340b80bc08946d813d65a3abf4ae923c43349d90ed71248\",\"license\":\"MIT\"},\"src/contracts/interfaces/IEligibility.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IEligibility {\\n    // Read functions.\\n    function name() external pure returns (string memory);\\n\\n    function finalized() external view returns (bool);\\n\\n    function targetAsset() external pure returns (address);\\n\\n    function checkAllEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function checkEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool[] memory);\\n\\n    function checkAllIneligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\\n\\n    // Write functions.\\n    function __Eligibility_init_bytes(bytes calldata configData) external;\\n\\n    function beforeMintHook(uint256[] calldata tokenIds) external;\\n\\n    function afterMintHook(uint256[] calldata tokenIds) external;\\n\\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\\n\\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0x2eeb6bdbe34301a2267cdda92a10c82b242406818873bcac89b691b2178689e7\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTCollection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\\\";\\n\\nimport \\\"./IEligibility.sol\\\";\\nimport \\\"./IFNFTCollectionFactory.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"../token/ERC20Upgradeable.sol\\\";\\n\\ninterface IFNFTCollection is IERC20Upgradeable {\\n    enum AuctionState { Inactive, Live, Ended }\\n\\n    struct Auction {\\n        uint256 livePrice;\\n        uint256 end;\\n        AuctionState state;\\n        address winning;\\n    }\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function curator() external view returns (address);\\n\\n    function assetAddress() external view returns (address);\\n\\n    function factory() external view returns (IFNFTCollectionFactory);\\n\\n    function eligibilityStorage() external view returns (IEligibility);\\n\\n    function is1155() external view returns (bool);\\n\\n    function allowAllItems() external view returns (bool);\\n\\n    function enableMint() external view returns (bool);\\n\\n    function enableRandomRedeem() external view returns (bool);\\n\\n    function enableTargetRedeem() external view returns (bool);\\n\\n    function enableRandomSwap() external view returns (bool);\\n\\n    function enableTargetSwap() external view returns (bool);\\n\\n    function enableBid() external view returns (bool);\\n\\n    function auctionLength() external view returns (uint256);\\n\\n    function quantity1155(uint256) external view returns (uint256);\\n\\n    function vaultId() external view returns (uint256);\\n\\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\\n\\n    function allHoldings() external view returns (uint256[] memory);\\n\\n    function totalHoldings() external view returns (uint256);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function randomRedeemFee() external view returns (uint256);\\n\\n    function targetRedeemFee() external view returns (uint256);\\n\\n    function randomSwapFee() external view returns (uint256);\\n\\n    function targetSwapFee() external view returns (uint256);\\n\\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function shutdown(address recipient) external;\\n\\n    function version() external returns (string memory);\\n\\n    function __FNFTCollection_init(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _curator,\\n        address _assetAddress,\\n        bool _is1155,\\n        bool _allowAllItems\\n    ) external;\\n\\n    function finalizeVault() external;\\n\\n    function setVaultMetadata(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n\\n    function setVaultFeatures(\\n        bool _enableMint,\\n        bool _enableRandomRedeem,\\n        bool _enableTargetRedeem,\\n        bool _enableRandomSwap,\\n        bool _enableTargetSwap,\\n        bool _enableBid\\n    ) external;\\n\\n    function setFees(\\n        uint256 _mintFee,\\n        uint256 _randomRedeemFee,\\n        uint256 _targetRedeemFee,\\n        uint256 _randomSwapFee,\\n        uint256 _targetSwapFee\\n    ) external;\\n\\n    function setAuctionLength(uint256 _auctionLength) external;\\n\\n    function disableVaultFees() external;\\n\\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\\n    // a similar interface.\\n    function deployEligibilityStorage(\\n        uint256 moduleIndex,\\n        bytes calldata initData\\n    ) external returns (address);\\n\\n    // The curator has control over options like fees and features\\n    function setCurator(address _curator) external;\\n\\n    function mint(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\\n    ) external returns (uint256);\\n\\n    function mintTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        address to\\n    ) external returns (uint256);\\n\\n    function redeem(uint256 amount, uint256[] calldata specificIds)\\n        external\\n        returns (uint256[] calldata);\\n\\n    function redeemTo(\\n        uint256 amount,\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n\\n    function swap(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds\\n    ) external returns (uint256[] calldata);\\n\\n    function swapTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n    function withdraw(uint256[] calldata tokenIds) external returns (uint256[] memory);\\n\\n    function startAuction(uint256 tokenId, uint256 price) external;\\n    function bid(uint256 tokenId, uint256 price) external;\\n    function endAuction(uint256 tokenId) external;\\n\\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\\n\\n    function flashLoan(\\n        IERC3156FlashBorrowerUpgradeable receiver,\\n        address borrowedToken,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function allValidNFTs(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getAuction(uint256 tokenId) external view returns (uint256, uint256, AuctionState, address);\\n    function getDepositor(uint256 tokenId) external view returns (address);\\n\\n    // /// @notice An event emitted when someone redeems all tokens for the NFT\\n    // event TokenRedeemed(address indexed redeemer);\\n\\n    event AuctionLengthUpdated(uint256 length);\\n    /// @notice An event emitted when an auction starts\\n    event AuctionStarted(address indexed buyer, uint256 tokenId, uint256 price);\\n    /// @notice An event emitted when an auction is won\\n    event AuctionWon(address indexed buyer, uint256 tokenId, uint256 price);\\n    /// @notice An event emitted when a bid is made\\n    event BidMade(address indexed buyer, uint256 tokenId, uint256 price);\\n    event CuratorUpdated(address oldCurator, address newCurator);\\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\\n    event Swapped(\\n        uint256[] nftIds,\\n        uint256[] amounts,\\n        uint256[] specificIds,\\n        uint256[] redeemedIds,\\n        address to\\n    );\\n    event VaultInit(\\n        uint256 indexed vaultId,\\n        address assetAddress,\\n        bool is1155,\\n        bool allowAllItems\\n    );\\n    event VaultFeaturesUpdated(\\n      bool enableMint,\\n      bool enableRandomRedeem,\\n      bool enableTargetRedeem,\\n      bool enableRandomSwap,\\n      bool enableTargetSwap,\\n      bool enableBid\\n    );\\n    event VaultShutdown(address assetAddress, uint256 numItems, address recipient);\\n\\n    error AuctionEnded();\\n    error AuctionLive();\\n    error AuctionNotEnded();\\n    error AuctionNotLive();\\n    error BidDisabled();\\n    error BidEnabled();\\n    error BidTooLow();\\n    error EligibilityAlreadySet();\\n    error FeeTooHigh();\\n    error IneligibleNFTs();\\n    error InvalidAuctionLength();\\n    error MintDisabled();\\n    error NFTAlreadyInCollection();\\n    error NotCurator();\\n    error NotNFTOwner();\\n    error NotInVault();\\n    error NotOwner();\\n    error Paused();\\n    error RandomRedeemDisabled();\\n    error RandomSwapDisabled();\\n    error TargetRedeemDisabled();\\n    error TargetSwapDisabled();\\n    error TooManyNFTs();\\n    error InvalidToken();\\n    error SameCurator();\\n    error ZeroAddress();\\n    error ZeroTransferAmount();\\n}\",\"keccak256\":\"0x73c0a4f17e8693c5a13b247941a378d2c5f7d597348a4a9dd132b000d094aa0e\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTCollectionFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"../proxy/IBeacon.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\n\\ninterface IFNFTCollectionFactory is IBeacon {\\n  struct VaultFees {\\n      bool active;\\n      uint64 mintFee;\\n      uint64 randomRedeemFee;\\n      uint64 targetRedeemFee;\\n      uint64 randomSwapFee;\\n      uint64 targetSwapFee;\\n  }\\n\\n  // Read functions.\\n  function vaultManager() external view returns (IVaultManager);\\n\\n  function eligibilityManager() external view returns (address);\\n\\n  function factoryMintFee() external view returns (uint64);\\n\\n  function factoryRandomRedeemFee() external view returns (uint64);\\n\\n  function factoryTargetRedeemFee() external view returns (uint64);\\n\\n  function factoryRandomSwapFee() external view returns (uint64);\\n\\n  function factoryTargetSwapFee() external view returns (uint64);\\n\\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n  function flashLoanFee() external view returns (uint256);\\n\\n  function maxAuctionLength() external view returns (uint256);\\n\\n  function minAuctionLength() external view returns (uint256);\\n\\n  function minBidIncrease() external view returns (uint256);\\n\\n  // Write functions.\\n  function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external;\\n\\n  function createVault(\\n      address _assetAddress,\\n      bool is1155,\\n      bool allowAllItems,\\n      string calldata _name,\\n      string calldata _symbol\\n  ) external returns (address);\\n\\n  function setEligibilityManager(address _eligibilityManager) external;\\n\\n  function setFactoryFees(\\n    uint256 _factoryMintFee,\\n    uint256 _factoryRandomRedeemFee,\\n    uint256 _factoryTargetRedeemFee,\\n    uint256 _factoryRandomSwapFee,\\n    uint256 _factoryTargetSwapFee,\\n    uint256 _flashLoanFee\\n  ) external;\\n\\n  function setFactoryThresholds(\\n      uint256 _maxAuctionLength,\\n      uint256 _minAuctionLength,\\n      uint256 _minBidIncrease\\n  ) external;\\n\\n  function setVaultFees(\\n      uint256 vaultId,\\n      uint256 _mintFee,\\n      uint256 _randomRedeemFee,\\n      uint256 _targetRedeemFee,\\n      uint256 _randomSwapFee,\\n      uint256 _targetSwapFee\\n  ) external;\\n\\n  function disableVaultFees(uint256 vaultId) external;\\n\\n  event FactoryThresholdsUpdated(uint256 maxAuctionLength, uint256 minAuctionLength, uint256 minBidIncrease);\\n  event EligibilityManagerUpdated(address oldEligManager, address newEligManager);\\n  event VaultCreated(uint256 indexed vaultId, address curator, address vaultAddress, address assetAddress, string name, string symbol);\\n  event VaultFeesUpdated(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\\n  event VaultFeesDisabled(uint256 vaultId);\\n  event FactoryFeesUpdated(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee, uint256 flashLoanFee);\\n\\n  error NotVault();\\n  error FeeTooHigh();\\n  error MaxAuctionLengthOutOfBounds();\\n  error MinAuctionLengthOutOfBounds();\\n  error MinBidIncreaseOutOfBounds();\\n  error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x3a40606069aab5c31d4d30a52ff4d834f5e67054eebdf3b6bbdd3d8ef97e7040\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./ITimelockExcludeList.sol\\\";\\n\\n\\ninterface IFNFTStaking {\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function inventoryLockTimeErc20() external view returns (uint256);\\n\\n    function timelockExcludeList() external view returns (ITimelockExcludeList);\\n\\n    function __FNFTStaking_init(address _vaultManager) external;\\n\\n    function setTimelockExcludeList(address _timelockExcludeList) external;\\n\\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external;\\n\\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) external returns (bool);\\n\\n    function deployXTokenForVault(uint256 vaultId) external;\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\\n\\n    function deposit(uint256 vaultId, uint256 _amount) external;\\n\\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external returns (uint256);\\n\\n    function withdraw(uint256 vaultId, uint256 _share) external;\\n\\n    function xTokenShareValue(uint256 vaultId) external returns (uint256);\\n\\n    function timelockUntil(uint256 vaultId, address who) external returns (uint256);\\n\\n    function balanceOf(uint256 vaultId, address who) external returns (uint256);\\n\\n    function xTokenAddr(address baseToken) external returns (address);\\n\\n    function vaultXToken(uint256 vaultId) external view returns (address);\\n\\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\\n    event BaseTokenDeposited(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, uint256 timelockUntil, address sender);\\n    event XTokenWithdrawn(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, address sender);\\n\\n    event InventoryLockTimeErc20Updated(uint256 oldInventoryLockTimeErc20, uint256 newInventoryLockTimeErc20);\\n    event TimelockExcludeListUpdated(address oldTimelockExcludeList, address newTimelockExcludeList);\\n\\n    error LockTooLong();\\n    error NotExcludedFromFees();\\n    error NotZapContract();\\n    error XTokenNotDeployed();\\n\\n}\",\"keccak256\":\"0xcdb51e91728e2f01a8b9090be9012d7f058c0b4875746782707a7d8d81e2706d\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFeeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./ILPStaking.sol\\\";\\nimport \\\"./IFNFTStaking.sol\\\";\\n\\ninterface IFeeDistributor {\\n\\n  struct FeeReceiver {\\n    uint256 allocPoint;\\n    address receiver;\\n    bool isContract;\\n  }\\n\\n  function distributionPaused() external returns (bool);\\n\\n  function vaultManager() external returns (IVaultManager);\\n\\n  function lpStaking() external returns (ILPStaking);\\n\\n  function fnftStaking() external returns (IFNFTStaking);\\n\\n  function treasury() external returns (address);\\n\\n  function allocTotal() external returns (uint256);\\n\\n  function feeReceivers(uint256) external returns (uint256, address, bool);\\n\\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external;\\n\\n  function rescueTokens(address token) external;\\n\\n  function distribute(uint256 vaultId) external;\\n\\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external;\\n\\n  function initializeVaultReceivers(uint256 _vaultId) external;\\n\\n  function changeReceiverAlloc(uint256 _idx, uint256 _allocPoint) external;\\n\\n  function changeReceiverAddress(uint256 _idx, address _address, bool _isContract) external;\\n\\n  function removeReceiver(uint256 _receiverIdx) external;\\n\\n  function setTreasuryAddress(address _treasury) external;\\n\\n  function setLPStakingAddress(address _lpStaking) external;\\n\\n  function setFNFTStakingAddress(address _inventoryStaking) external;\\n\\n  function pauseFeeDistribution(bool _pause) external;\\n\\n  event TreasuryAddressUpdated(address newTreasury);\\n  event LPStakingAddressUpdated(address newLPStaking);\\n  event FNFTStakingAddressUpdated(address newFNFTStaking);\\n  event DistributionPaused(bool paused);\\n  event FeeReceiverAdded(address receiver, uint256 allocPoint);\\n  event FeeReceiverAllocUpdated(address receiver, uint256 allocPoint);\\n  event FeeReceiverAddressUpdated(address oldReceiver, address newReceiver);\\n  event FeeReceiverRemoved(address receiver);\\n\\n  error NotVaultManager();\\n  error OutOfBounds();\\n  error ZeroAddress();\\n}\",\"keccak256\":\"0x0bb4491305e0e5122e03adb57d47daca2e3df92389a818ec3fa8463045b9f582\",\"license\":\"MIT\"},\"src/contracts/interfaces/ILPStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./IStakingTokenProvider.sol\\\";\\nimport \\\"../token/LPStakingXTokenUpgradeable.sol\\\";\\n\\ninterface ILPStaking {\\n    struct StakingPool {\\n        address stakingToken;\\n        address baseToken;\\n    }\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function stakingTokenProvider() external view returns (IStakingTokenProvider);\\n\\n    function lpStakingXToken() external view returns (LPStakingXTokenUpgradeable);\\n\\n    function vaultStakingInfo(uint256) external view returns (address, address);\\n\\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external;\\n\\n    function setStakingTokenProvider(address _stakingTokenProvider) external;\\n\\n    function addPoolForVault(uint256 vaultId) external;\\n\\n    function updatePoolForVaults(uint256[] calldata vaultIds) external;\\n\\n    function updatePoolForVault(uint256 vaultId) external;\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\\n\\n    function deposit(uint256 vaultId, uint256 amount) external;\\n\\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\\n\\n    function exit(uint256 vaultId) external;\\n\\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external;\\n\\n    function emergencyExit(address _stakingToken, address _baseToken) external;\\n\\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external;\\n\\n    function claimRewardsTo(uint256 vaultId, address to) external;\\n\\n    function claimMultipleRewards(uint256[] calldata vaultIds) external;\\n\\n    function xToken(uint256 vaultId) external view returns (LPStakingXTokenUpgradeable);\\n\\n    function xTokenAddr(address stakedToken, address baseToken) external view returns (address);\\n\\n    function balanceOf(uint256 vaultId, address addr) external view returns (uint256);\\n\\n    function lockedUntil(uint256 vaultId, address who) external view returns (uint256);\\n\\n    function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256);\\n\\n    function xToken(StakingPool memory pool) external view returns (LPStakingXTokenUpgradeable);\\n\\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) external;\\n\\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\\n    event StakingPoolUpdated(uint256 vaultId, address xToken);\\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\\n    event LPDeposited(uint256 vaultId, uint256 amount, address xToken, address sender);\\n    event XTokenWithdrawn(uint256 vaultId, uint256 amount, address xToken, address sender);\\n    event StakingTokenProviderUpdated(address oldStakingTokenProvider, address newStakingTokenProvider);\\n\\n    error NotAPool();\\n    error NotDeployingProperDistro();\\n    error NotExcludedFromFees();\\n    error NothingToMigrate();\\n    error PoolAlreadyExists();\\n    error PoolDoesNotExist();\\n    error LPStakingXTokenAlreadySet();\\n    error TimelockTooLong();\\n    error VaultManagerAlreadySet();\\n    error VaultManagerNotSet();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x6c8766af488b3c056fb361a8e507618ebf80011baa1aee29d0400942920abbbf\",\"license\":\"MIT\"},\"src/contracts/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {    \\n    function transferOwnership(address newOwner) external;\\n}\",\"keccak256\":\"0x9716971d2cc675c21348080f2678c3af6199ea5632bfac3a81d9f1da5bb685c8\",\"license\":\"MIT\"},\"src/contracts/interfaces/IStakingTokenProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IStakingTokenProvider {\\n    function uniLikeExchange() external returns (address);\\n\\n    function defaultPairedToken() external returns (address);\\n\\n    function defaultPrefix() external returns (string memory);\\n\\n    function pairedToken(address) external returns (address);\\n\\n    function pairedPrefix(address) external returns (string memory);\\n\\n    function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) external;\\n\\n    function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external;\\n\\n    function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external;\\n\\n    function stakingTokenForVaultToken(address _vaultToken) external view returns (address);\\n\\n    function nameForStakingToken(address _vaultToken) external view returns (string memory);\\n\\n    function pairForVaultToken(address _vaultToken, address _pairedToken) external view returns (address);\\n\\n    event DefaultPairedTokenUpdated(address oldDefaultPairedToken, address newDefaultPairedToken);\\n    event PairedTokenForVaultUpdated(address vaultToken, address oldPairedtoken, address newPairedToken);\\n\\n    error IdenticalAddress();\\n    error ZeroAddress();\\n}\",\"keccak256\":\"0x9e1fb1537606cdea4faf2baf748657800337b12d2586f1f83cc3d96cbaec17ce\",\"license\":\"MIT\"},\"src/contracts/interfaces/ITimelockExcludeList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface ITimelockExcludeList {\\n    function isExcluded(address addr, uint256 vaultId) external view returns (bool);\\n}\",\"keccak256\":\"0xb908cf66c38d674f2970c91a15f5edb3c8b310261b0cd70f61f936feb02eab8d\",\"license\":\"MIT\"},\"src/contracts/interfaces/IVaultManager.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IVaultManager {\\n    function fnftSingleFactory() external view returns (address);\\n\\n    function fnftCollectionFactory() external view returns (address);\\n\\n    function excludedFromFees(address) external view returns (bool);\\n\\n    function feeDistributor() external view returns (address);\\n\\n    function __VaultManager_init(address _weth) external;\\n\\n    function WETH() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function ifoFactory() external view returns (address);\\n\\n    function zapContract() external view returns (address);\\n\\n    function feeReceiver() external view returns (address payable);\\n\\n    function togglePaused() external;\\n\\n    function addVault(address _fnft) external returns (uint256 vaultId);\\n\\n    function setPriceOracle(address _priceOracle) external;\\n\\n    function setFeeDistributor(address _feeDistributor) external;\\n\\n    function setFeeExclusion(address _address, bool _excluded) external;\\n\\n    function setFeeReceiver(address payable _feeReceiver) external;\\n\\n    function setIFOFactory(address _ifoFactory) external;\\n\\n    function setZapContract(address _zapContract) external;\\n\\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external;\\n\\n    function setFNFTSingleFactory(address _fnftCollectionFactory) external;\\n\\n    function vault(uint256 vaultId) external view returns (address);\\n\\n    function vaults(uint256) external view returns (address);\\n\\n    function numVaults() external view returns (uint);\\n\\n    event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\\n    event IFOFactoryUpdated(address oldIFOFactory, address newIFOFactory);\\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\\n    event ZapContractUpdated(address oldZapContract, address newZapContract);\\n    event FNFTCollectionFactoryUpdated(address oldFNFTCollectionFactory, address newFNFTCollectionFactory);\\n    event FNFTSingleFactoryUpdated(address oldFNFTSingleFactory, address newFNFTSingleFactory);\\n    event VaultAdded(uint256 vaultId, address vault);\\n    event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\\n    event FeeExclusionUpdated(address target, bool excluded);\\n\\n    error FeeTooHigh();\\n    error MaxAuctionLengthOutOfBounds();\\n    error MaxReserveFactorTooLow();\\n    error MinAuctionLengthOutOfBounds();\\n    error MinBidIncreaseOutOfBounds();\\n    error MinReserveFactorTooHigh();\\n    error MinVotePercentageTooHigh();\\n    error MultiplierTooLow();\\n    error OnlyFactory();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0xf883c7d6e14d75bac6f1b2533293234d93608e563d45d79b80b3d31ee07395f2\",\"license\":\"MIT\"},\"src/contracts/proxy/AdminUpgradeabilityProxy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title BaseAdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\\n  /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n  event AdminChanged(address previousAdmin, address newAdmin);\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  /**\\n   * Contract constructor.\\n   * @param _logic address of the initial implementation.\\n   * @param _adm Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, address _adm, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n    _setAdmin(_adm);\\n  }\\n\\n  /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n  modifier ifAdmin() {\\n    if (msg.sender == _admin()) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return _admin();\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n  function changeAdmin(address newAdmin) external ifAdmin {\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n    emit AdminChanged(_admin(), newAdmin);\\n    _setAdmin(newAdmin);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\n    _upgradeTo(newImplementation);\\n    (bool success,) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @return adm The admin slot.\\n   */\\n  function _admin() internal view returns (address adm) {\\n    bytes32 slot = ADMIN_SLOT;\\n    assembly {\\n      adm := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n  function _setAdmin(address newAdmin) internal {\\n    bytes32 slot = ADMIN_SLOT;\\n\\n    assembly {\\n      sstore(slot, newAdmin)\\n    }\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override {\\n    require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n    super._willFallback();\\n  }\\n}\",\"keccak256\":\"0x0b503f72e19deca4b7da231f0cb4c4c224b0dacc56d8f239a428550ae2471247\",\"license\":\"MIT\"},\"src/contracts/proxy/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(beacon, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).childImplementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).childImplementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0xf4d4c86d46f7e3eed9c0a799bac7a41c6669b8f216d24d435c5d95497397d3ba\",\"license\":\"MIT\"},\"src/contracts/proxy/BeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract BeaconUpgradeable is OwnableUpgradeable, IBeacon {\\n    address private _childImplementation;\\n\\n    /**\\n     * @dev Emitted when the child implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed childImplementation);\\n\\n    function __BeaconUpgradeable__init(address childImplementation_) public initializer {\\n        _setChildImplementation(childImplementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current child implementation address.\\n     */\\n    function childImplementation() public view virtual override returns (address) {\\n        return _childImplementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newChildImplementation` must be a contract.\\n     */\\n    function upgradeChildTo(address newChildImplementation) external virtual override onlyOwner {\\n        _setChildImplementation(newChildImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newChildImplementation` must be a contract.\\n     */\\n    function _setChildImplementation(address newChildImplementation) private {\\n        require(Address.isContract(newChildImplementation), \\\"UpgradeableBeacon: child implementation is not a contract\\\");\\n        _childImplementation = newChildImplementation;\\n        emit Upgraded(newChildImplementation);\\n    }\\n}\",\"keccak256\":\"0x2258f167a87cad73f9a5ce3daf73bf232c3179a79961e903d57468c20343cb16\",\"license\":\"MIT\"},\"src/contracts/proxy/Create2BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n * Slightly modified to allow using beacon proxies with Create2.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract Create2BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor() payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(msg.sender, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).childImplementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).childImplementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0x40d5892e65825c3e6171f0f876ca3410728f0766b11a1c76f1b3149a233932f2\",\"license\":\"MIT\"},\"src/contracts/proxy/Deployer.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../VaultManager.sol\\\";\\nimport \\\"../FNFTCollectionFactory.sol\\\";\\nimport \\\"../FeeDistributor.sol\\\";\\nimport \\\"../FNFTStaking.sol\\\";\\nimport \\\"../LPStaking.sol\\\";\\nimport \\\"../StakingTokenProvider.sol\\\";\\nimport \\\"./AdminUpgradeabilityProxy.sol\\\";\\nimport \\\"./IMultiProxyController.sol\\\";\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\ncontract Deployer is Ownable {\\n    event ProxyDeployed(\\n        bytes32 indexed identifier,\\n        address logic,\\n        address creator\\n    );\\n\\n    error NoController();\\n\\n    IMultiProxyController public proxyController;\\n\\n    bytes32 constant public FNFT_COLLECTION_FACTORY = bytes32(0x464e4654436f6c6c656374696f6e466163746f72790000000000000000000000);\\n    bytes32 constant public VAULT_MANAGER = bytes32(0x5661756c744d616e616765720000000000000000000000000000000000000000);\\n    bytes32 constant public FEE_DISTRIBUTOR = bytes32(0x4665654469737472696275746f72000000000000000000000000000000000000);\\n    bytes32 constant public INVENTORY_STAKING = bytes32(0x496e76656e746f72795374616b696e6700000000000000000000000000000000);\\n    bytes32 constant public LP_STAKING = bytes32(0x4c505374616b696e670000000000000000000000000000000000000000000000);\\n    bytes32 constant public STAKING_TOKEN_PROVIDER = bytes32(0x5374616b696e67546f6b656e50726f7669646572000000000000000000000000);\\n\\n    // Gov\\n\\n    function setProxyController(address _proxyController) external onlyOwner {\\n        proxyController = IMultiProxyController(_proxyController);\\n    }\\n\\n    /// @notice the function to deploy FeeDistributor\\n    /// @param _logic the implementation\\n    function deployFeeDistributor(address _logic, address vaultManager, address lpStaking, address treasury) external onlyOwner returns (address feeDistributor) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FeeDistributor.__FeeDistributor_init.selector,\\n            vaultManager,\\n            lpStaking,\\n            treasury\\n        );\\n\\n        feeDistributor = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(feeDistributor).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(FEE_DISTRIBUTOR, feeDistributor);\\n\\n        emit ProxyDeployed(FEE_DISTRIBUTOR, feeDistributor, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTCollectionFactory\\n    /// @param _logic the implementation\\n    function deployVaultManager(\\n        address _logic,\\n        address _weth\\n    ) external onlyOwner returns (address vaultManager) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            VaultManager.__VaultManager_init.selector,\\n            _weth\\n        );\\n\\n        vaultManager = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(vaultManager).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(VAULT_MANAGER, vaultManager);\\n\\n        emit ProxyDeployed(VAULT_MANAGER, vaultManager, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTCollectionFactory\\n    /// @param _logic the implementation\\n    /// @param _vaultManager variable needed for FNFTCollectionFactory\\n    function deployFNFTCollectionFactory(\\n        address _logic,\\n        address _vaultManager,\\n        address _fnftCollection\\n    ) external onlyOwner returns (address factory) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FNFTCollectionFactory.__FNFTCollectionFactory_init.selector,\\n            _vaultManager,\\n            _fnftCollection\\n        );\\n\\n        factory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(factory).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(FNFT_COLLECTION_FACTORY, factory);\\n\\n        emit ProxyDeployed(FNFT_COLLECTION_FACTORY, factory, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy LPStaking\\n    /// @param _logic the implementation\\n    function deployLPStaking(address _logic, address vaultManager, address stakingTokenProvider) external onlyOwner returns (address lpStaking) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            LPStaking.__LPStaking__init.selector,\\n            vaultManager,\\n            stakingTokenProvider\\n        );\\n\\n        lpStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(lpStaking).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(LP_STAKING, lpStaking);\\n\\n        emit ProxyDeployed(LP_STAKING, lpStaking, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTStaking\\n    /// @param _logic the implementation\\n    function deployFNFTStaking(address _logic, address fnftCollectionFactory) external onlyOwner returns (address fnftStaking) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FNFTStaking.__FNFTStaking_init.selector,\\n            fnftCollectionFactory\\n        );\\n\\n        fnftStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(fnftStaking).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(INVENTORY_STAKING, fnftStaking);\\n\\n        emit ProxyDeployed(INVENTORY_STAKING, fnftStaking, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy StakingTokenProvider\\n    /// @param _logic the implementation\\n    function deployStakingTokenProvider(address _logic, address uniswapV2Factory, address defaultPairedToken, string memory defaultPrefix) external onlyOwner returns (address stakingTokenProvider) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            StakingTokenProvider.__StakingTokenProvider_init.selector,\\n            uniswapV2Factory,\\n            defaultPairedToken,\\n            defaultPrefix\\n        );\\n\\n        stakingTokenProvider = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(stakingTokenProvider).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(STAKING_TOKEN_PROVIDER, stakingTokenProvider);\\n\\n        emit ProxyDeployed(STAKING_TOKEN_PROVIDER, stakingTokenProvider, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x822ae73b604664f5e1882f2e1a9256674a14b9f793ee96ab0a5b9f7214b6c95e\",\"license\":\"MIT\"},\"src/contracts/proxy/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function childImplementation() external view returns (address);\\n    function upgradeChildTo(address newImplementation) external;\\n}\",\"keccak256\":\"0x2ee2683fe16040709f07a18653117d408b026c5f9eb933b3b6af6d26b617f35c\",\"license\":\"MIT\"},\"src/contracts/proxy/IMultiProxyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IMultiProxyController {\\n    function deployerUpdateProxy(bytes32 key, address proxy) external;\\n}\",\"keccak256\":\"0x7c2e20bdd1a160302377f386cbc1b62c21d048e53b9b8209e0de09b2be37dbaf\",\"license\":\"MIT\"},\"src/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n    * @dev Function that is run as the first thing in the fallback function.\\n    * Can be redefined in derived contracts to add functionality.\\n    * Redefinitions must call super._willFallback().\\n    */\\n    function _willFallback() internal virtual {\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\",\"keccak256\":\"0xe39547f99ea306cdbea6d184b91c94a4da952605da3ee9175aa27075fee6032e\",\"license\":\"MIT\"},\"src/contracts/proxy/UpgradeabilityProxy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title UpgradabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Contract constructor.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, bytes memory _data) payable {\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n    _setImplementation(_logic);\\n    if(_data.length > 0) {\\n      (bool success,) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }  \\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(Address.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\",\"keccak256\":\"0x8f9cbea989ff2a4ef5ed3099af03bd9d72e4016ff8b5ebad710d4f37443cc24b\",\"license\":\"MIT\"},\"src/contracts/token/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function _setMetadata(string memory name_, string memory symbol_) internal {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\",\"keccak256\":\"0x6ffb3595113d54827e8eca1b15cf843744a8d5865bb591ba974a7d978b9ea571\",\"license\":\"MIT\"},\"src/contracts/token/FNFTStakingXTokenUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./ERC20Upgradeable.sol\\\";\\n\\n// XTokens let you come in with some vault tokens, and leave with more! The longer you stay, the more vault tokens you get.\\n//\\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\\ncontract FNFTStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 internal constant MAX_TIMELOCK = 2592000;\\n    IERC20Upgradeable public baseToken;\\n\\n    mapping(address => uint256) internal timelock;\\n\\n    event Timelocked(address user, uint256 until);\\n\\n    error LockTooLong();\\n    error UserIsLocked();\\n\\n    function __FNFTStakingXToken_init(address _baseToken, string memory name, string memory symbol) public initializer {\\n        __Ownable_init();\\n        __ERC20_init(name, symbol);\\n        baseToken = IERC20Upgradeable(_baseToken);\\n    }\\n\\n    function burnXTokens(address who, uint256 _share) external onlyOwner returns (uint256) {\\n        // Gets the amount of xToken in existence\\n        uint256 totalShares = totalSupply();\\n        // Calculates the amount of base tokens the xToken is worth\\n        uint256 what = (_share * baseToken.balanceOf(address(this))) / totalShares;\\n        _burn(who, _share);\\n        baseToken.safeTransfer(who, what);\\n        return what;\\n    }\\n\\n    // Needs to be called BEFORE new base tokens are deposited.\\n    function mintXTokens(address account, uint256 _amount, uint256 timelockLength) external onlyOwner returns (uint256) {\\n        // Gets the amount of Base Token locked in the contract\\n        uint256 totalBaseToken = baseToken.balanceOf(address(this));\\n        // Gets the amount of xTokens in existence\\n        uint256 totalShares = totalSupply();\\n        // If no xTokens exist, mint it 1:1 to the amount put in\\n        if (totalShares == 0 || totalBaseToken == 0) {\\n            _timelockMint(account, _amount, timelockLength);\\n            return _amount;\\n        }\\n        // Calculate and mint the amount of xTokens the base tokens are worth. The ratio will change overtime, as xTokens are burned/minted and base tokens deposited + gained from fees / withdrawn.\\n        else {\\n            uint256 what = (_amount * totalShares) / totalBaseToken;\\n            _timelockMint(account, what, timelockLength);\\n            return what;\\n        }\\n    }\\n\\n    function timelockUntil(address account) external view returns (uint256) {\\n        return timelock[account];\\n    }\\n\\n    function timelockAccount(address account, uint256 timelockLength) public onlyOwner {\\n        if (timelockLength >= MAX_TIMELOCK) revert LockTooLong();\\n        uint256 timelockFinish = block.timestamp + timelockLength;\\n        if (timelockFinish > timelock[account]) {\\n            timelock[account] = timelockFinish;\\n            emit Timelocked(account, timelockFinish);\\n        }\\n    }\\n\\n    function _burn(address who, uint256 amount) internal override {\\n        if (timelock[who] >= block.timestamp) revert UserIsLocked();\\n        super._burn(who, amount);\\n    }\\n\\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal {\\n        timelockAccount(account, timelockLength);\\n        _mint(account, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal override {\\n        if (timelock[from] >= block.timestamp) revert UserIsLocked();\\n        super._transfer(from, to, value);\\n    }\\n}\",\"keccak256\":\"0xb3b73b6cb9017172ce554eba86c8b7d89368080404643b0e608395c629a48db1\",\"license\":\"MIT\"},\"src/contracts/token/LPStakingXTokenUpgradeable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @title Reward-Paying Token (renamed from Dividend)\\n/// @author Roger Wu (https://github.com/roger-wu)\\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute a target token\\n///  to token holders as dividends and allows token holders to withdraw their dividends.\\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\\ncontract LPStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\\n  using SafeCast for uint256;\\n  using SafeCast for int256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  IERC20Upgradeable public target;\\n\\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\\n  // For more discussion about choosing the value of `magnitude`,\\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\\n  uint256 constant internal magnitude = 2**128;\\n\\n  uint256 internal magnifiedRewardPerShare;\\n\\n  // About dividendCorrection:\\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\\n  //   `dividendOf(_user)` should not be changed,\\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\\n  mapping(address => int256) internal magnifiedRewardCorrections;\\n  mapping(address => uint256) internal withdrawnRewards;\\n\\n  mapping(address => uint256) internal timelock;\\n\\n  event Timelocked(address user, uint256 amount, uint256 until);\\n\\n  error UserIsLocked();\\n  error ZeroAmount();\\n  error ZeroSupply();\\n\\n  function __LPStakingXToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\\n    __Ownable_init();\\n    __ERC20_init(_name, _symbol);\\n    target = _target;\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n      public\\n      virtual\\n      override\\n      returns (bool)\\n  {\\n      _transfer(_msgSender(), recipient, amount);\\n      return true;\\n  }\\n\\n  /**\\n    * @dev See {IERC20-transferFrom}.\\n    *\\n    * Emits an {Approval} event indicating the updated allowance. This is not\\n    * required by the EIP. See the note at the beginning of {ERC20}.\\n    *\\n    * Requirements:\\n    *\\n    * - `sender` and `recipient` cannot be the zero address.\\n    * - `sender` must have a balance of at least `amount`.\\n    * - the caller must have allowance for ``sender``'s tokens of at least\\n    * `amount`.\\n    */\\n  function transferFrom(address sender, address recipient, uint256 amount)\\n      public\\n      virtual\\n      override\\n      returns (bool)\\n  {\\n      _transfer(sender, recipient, amount);\\n      _approve(sender, _msgSender(), allowance(sender, _msgSender()) - amount);\\n      return true;\\n  }\\n\\n  function mint(address account, uint256 amount) public onlyOwner virtual {\\n      _mint(account, amount);\\n  }\\n\\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\\n    uint256 timelockFinish = block.timestamp + timelockLength;\\n    timelock[account] = timelockFinish;\\n    emit Timelocked(account, amount, timelockFinish);\\n    _mint(account, amount);\\n  }\\n\\n  function timelockUntil(address account) public view returns (uint256) {\\n    return timelock[account];\\n  }\\n\\n  /**\\n    * @dev Destroys `amount` tokens from `account`, without deducting from the caller's\\n    * allowance. Dangerous.\\n    *\\n    * See {ERC20-_burn} and {ERC20-allowance}.\\n    */\\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\\n      _burn(account, amount);\\n  }\\n\\n  /// @notice Distributes target to token holders as dividends.\\n  /// @dev It reverts if the total supply of tokens is 0.\\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\\n  /// About undistributed target tokens:\\n  ///   In each distribution, there is a small amount of target not distributed,\\n  ///     the magnified amount of which is\\n  ///     `(amount * magnitude) % totalSupply()`.\\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\\n  ///     (de-magnified) in a distribution can be less than 1 wei.\\n  ///   We can actually keep track of the undistributed target in a distribution\\n  ///     and try to distribute it in the next distribution,\\n  ///     but keeping track of such data on-chain costs much more than\\n  ///     the saved target, so we don't do that.\\n  function distributeRewards(uint amount) external virtual onlyOwner {\\n    if (totalSupply() == 0) revert ZeroSupply();\\n    if (amount == 0) revert ZeroAmount();\\n\\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\\n    magnifiedRewardPerShare = magnifiedRewardPerShare + (amount * magnitude / totalSupply());\\n\\n    emit RewardsDistributed(msg.sender, amount);\\n  }\\n\\n  /// @notice Withdraws the target distributed to the sender.\\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\\n  function withdrawReward(address user) external onlyOwner {\\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\\n    if (_withdrawableReward > 0) {\\n      withdrawnRewards[user] = withdrawnRewards[user] + _withdrawableReward;\\n      target.safeTransfer(user, _withdrawableReward);\\n      emit RewardWithdrawn(user, _withdrawableReward);\\n    }\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\n  function dividendOf(address _owner) public view returns(uint256) {\\n    return withdrawableRewardOf(_owner);\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\\n    return accumulativeRewardOf(_owner) - withdrawnRewards[_owner];\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\\n    return withdrawnRewards[_owner];\\n  }\\n\\n\\n  /// @notice View the amount of dividend in wei that an address has earned in total.\\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\\n    return ((magnifiedRewardPerShare * balanceOf(_owner)).toInt256() + magnifiedRewardCorrections[_owner]).toUint256() / magnitude;\\n  }\\n\\n  /// @dev Internal function that transfer tokens from one address to another.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param from The address to transfer from.\\n  /// @param to The address to transfer to.\\n  /// @param value The amount to be transferred.\\n  function _transfer(address from, address to, uint256 value) internal override {\\n    if (timelock[from] >= block.timestamp) revert UserIsLocked();\\n    super._transfer(from, to, value);\\n\\n    int256 _magCorrection = (magnifiedRewardPerShare * value).toInt256();\\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from] + _magCorrection;\\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to] - _magCorrection;\\n  }\\n\\n  /// @dev Internal function that mints tokens to an account.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param account The account that will receive the created tokens.\\n  /// @param value The amount that will be created.\\n  function _mint(address account, uint256 value) internal override {\\n    super._mint(account, value);\\n\\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] - (magnifiedRewardPerShare * value).toInt256();\\n  }\\n\\n  /// @dev Internal function that burns an amount of the token of a given account.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param account The account whose tokens will be burnt.\\n  /// @param value The amount that will be burnt.\\n  function _burn(address account, uint256 value) internal override {\\n    if (timelock[account] >= block.timestamp) revert UserIsLocked();\\n    super._burn(account, value);\\n\\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] + (magnifiedRewardPerShare * value).toInt256();\\n  }\\n\\n\\n  /// @dev This event MUST emit when target is distributed to token holders.\\n  /// @param from The address which sends target to this contract.\\n  /// @param weiAmount The amount of distributed target in wei.\\n  event RewardsDistributed(\\n    address indexed from,\\n    uint256 weiAmount\\n  );\\n\\n  /// @dev This event MUST emit when an address withdraws their dividend.\\n  /// @param to The address which withdraws target from this contract.\\n  /// @param weiAmount The amount of withdrawn target in wei.\\n  event RewardWithdrawn(\\n    address indexed to,\\n    uint256 weiAmount\\n  );\\n}\",\"keccak256\":\"0xb1c86212e64708255110a346342716f0abd0f7a1b9713bc8b3f295a73b0c062d\",\"license\":\"Unlicense\"},\"src/contracts/util/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract Pausable is OwnableUpgradeable {\\n\\n    function __Pausable_init() internal initializer {\\n        __Ownable_init();\\n    }\\n\\n    event SetIsGuardian(address addr, bool isGuardian);\\n    event SetPaused(uint256 lockId, bool paused);\\n\\n    mapping(address => bool) public isGuardian;\\n    mapping(uint256 => bool) public isPaused;\\n    // 0  : createVault\\n    // 1  : mint\\n    // 2  : redeem\\n    // 3  : swap\\n    // 4  : auction\\n    // 5  : flashloan\\n    // 6  : fee\\n    // 7  : price\\n    // 10 : stake\\n\\n    error Paused();\\n    error Unauthorized();\\n\\n    function onlyOwnerIfPaused(uint256 lockId) public view virtual {\\n        if (isPaused[lockId] && msg.sender != owner()) revert Paused();\\n    }\\n\\n    function pause(uint256 lockId) public virtual {\\n        if (!isGuardian[msg.sender]) revert Unauthorized();\\n        isPaused[lockId] = true;\\n        emit SetPaused(lockId, true);\\n    }\\n\\n    function setIsGuardian(address _address, bool _isGuardian) public virtual onlyOwner {\\n        isGuardian[_address] = _isGuardian;\\n        emit SetIsGuardian(_address, _isGuardian);\\n    }\\n\\n    function unpause(uint256 lockId)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        isPaused[lockId] = false;\\n        emit SetPaused(lockId, false);\\n    }\\n}\\n\",\"keccak256\":\"0x63dab5ed768e7ff4157e8dc9c794ad3800b26c5b7beb4392aab586e118a83b69\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611d8e8061007e6000396000f3fe60806040523480156200001157600080fd5b5060043610620001215760003560e01c80638da5cb5b11620000af578063bc22ff4e116200007a578063bc22ff4e146200025e578063c0a697c91462000275578063ef9bf15a1462000289578063f23fa79414620002a4578063f2fde38b14620002c357600080fd5b80638da5cb5b14620001fe578063a36ab4691462000210578063b70245f21462000227578063b808755e146200024757600080fd5b806364b1f9a111620000f057806364b1f9a114620001ad5780636910dcce14620001c4578063715018a614620001dd57806377881c7b14620001e757600080fd5b8063114c20f014620001265780633da0c131146200014d5780634352aa9f146200017d5780635da43bc91462000196575b600080fd5b6200013a684c505374616b696e6760b81b81565b6040519081526020015b60405180910390f35b620001646200015e36600462001070565b620002da565b6040516001600160a01b03909116815260200162000144565b620001946200018e366004620010ba565b620004f7565b005b62000164620001a736600462001070565b62000546565b62000164620001be366004620010df565b62000732565b6200013a6d2332b2a234b9ba3934b13aba37b960911b81565b6200019462000923565b62000164620001f83660046200112d565b6200095e565b6000546001600160a01b031662000164565b620001646200022136600462001220565b62000b73565b6200013a74464e4654436f6c6c656374696f6e466163746f727960581b81565b6200016462000258366004620010df565b62000d69565b6200013a6b2b30bab63a26b0b730b3b2b960a11b81565b60015462000164906001600160a01b031681565b6200013a6f496e76656e746f72795374616b696e6760801b81565b6200013a7329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b81565b62000194620002d4366004620010ba565b62000f53565b600080546001600160a01b03163314620003115760405162461bcd60e51b815260040162000308906200127d565b60405180910390fd5b6001546001600160a01b03166200033b57604051630d17f6b760e41b815260040160405180910390fd5b600063afccd7c360e01b84846040516024016200035a929190620012b2565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620003a09062001045565b620003ae939291906200131c565b604051809103906000f080158015620003cb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200041157600080fd5b505af115801562000426573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815274464e4654436f6c6c656374696f6e466163746f727960581b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200049057600080fd5b505af1158015620004a5573d6000803e3d6000fd5b5050505074464e4654436f6c6c656374696f6e466163746f727960581b60001b60008051602062001d398339815191528333604051620004e7929190620012b2565b60405180910390a2509392505050565b6000546001600160a01b03163314620005245760405162461bcd60e51b815260040162000308906200127d565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600080546001600160a01b03163314620005745760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b03166200059e57604051630d17f6b760e41b815260040160405180910390fd5b600063f79b61ba60e01b8484604051602401620005bd929190620012b2565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620006039062001045565b62000611939291906200131c565b604051809103906000f0801580156200062e573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200067457600080fd5b505af115801562000689573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b8152684c505374616b696e6760b81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620006e757600080fd5b505af1158015620006fc573d6000803e3d6000fd5b50505050684c505374616b696e6760b81b60001b60008051602062001d398339815191528333604051620004e7929190620012b2565b600080546001600160a01b03163314620007605760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b03166200078a57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b031663399cb35360e11b1790529051849033908390620007df9062001045565b620007ed939291906200131c565b604051809103906000f0801580156200080a573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200085057600080fd5b505af115801562000865573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526b2b30bab63a26b0b730b3b2b960a11b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620008c657600080fd5b505af1158015620008db573d6000803e3d6000fd5b505050506b2b30bab63a26b0b730b3b2b960a11b60001b60008051602062001d39833981519152833360405162000914929190620012b2565b60405180910390a25092915050565b6000546001600160a01b03163314620009505760405162461bcd60e51b815260040162000308906200127d565b6200095c600062000ff5565b565b600080546001600160a01b031633146200098c5760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b0316620009b657604051630d17f6b760e41b815260040160405180910390fd5b6000638a2a1e2f60e01b858585604051602401620009d7939291906200131c565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b038381831617835250505050905085338260405162000a1d9062001045565b62000a2b939291906200131c565b604051809103906000f08015801562000a48573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000a8e57600080fd5b505af115801562000aa3573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81527329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000b0c57600080fd5b505af115801562000b21573d6000803e3d6000fd5b505050507329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60001b60008051602062001d39833981519152833360405162000b62929190620012b2565b60405180910390a250949350505050565b600080546001600160a01b0316331462000ba15760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b031662000bcb57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b0316637aed47c560e01b179052905186903390839062000c309062001045565b62000c3e939291906200131c565b604051809103906000f08015801562000c5b573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000ca157600080fd5b505af115801562000cb6573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526d2332b2a234b9ba3934b13aba37b960911b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000d1957600080fd5b505af115801562000d2e573d6000803e3d6000fd5b505050506d2332b2a234b9ba3934b13aba37b960911b60001b60008051602062001d39833981519152833360405162000b62929190620012b2565b600080546001600160a01b0316331462000d975760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b031662000dc157604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b0316636bf4b28d60e01b179052905184903390839062000e169062001045565b62000e24939291906200131c565b604051809103906000f08015801562000e41573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000e8757600080fd5b505af115801562000e9c573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526f496e76656e746f72795374616b696e6760801b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000f0157600080fd5b505af115801562000f16573d6000803e3d6000fd5b505050506f496e76656e746f72795374616b696e6760801b60001b60008051602062001d39833981519152833360405162000914929190620012b2565b6000546001600160a01b0316331462000f805760405162461bcd60e51b815260040162000308906200127d565b6001600160a01b03811662000fe75760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840162000308565b62000ff28162000ff5565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6109e5806200135483390190565b80356001600160a01b03811681146200106b57600080fd5b919050565b6000806000606084860312156200108657600080fd5b620010918462001053565b9250620010a16020850162001053565b9150620010b16040850162001053565b90509250925092565b600060208284031215620010cd57600080fd5b620010d88262001053565b9392505050565b60008060408385031215620010f357600080fd5b620010fe8362001053565b91506200110e6020840162001053565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156200114457600080fd5b6200114f8562001053565b93506200115f6020860162001053565b92506200116f6040860162001053565b9150606085013567ffffffffffffffff808211156200118d57600080fd5b818701915087601f830112620011a257600080fd5b813581811115620011b757620011b762001117565b604051601f8201601f19908116603f01168101908382118183101715620011e257620011e262001117565b816040528281528a6020848701011115620011fc57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080600080608085870312156200123757600080fd5b620012428562001053565b9350620012526020860162001053565b9250620012626040860162001053565b9150620012726060860162001053565b905092959194509250565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b0392831681529116602082015260400190565b6000815180845260005b81811015620012f457602081850181015186830182015201620012d6565b8181111562001307576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b038481168252831660208201526060604082018190526000906200134a90830184620012cc565b9594505050505056fe6080604052604051620009e5380380620009e583398101604081905262000026916200027d565b82816200005560017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd6200035d565b600080516020620009c58339815191521462000075576200007562000383565b620000808262000168565b805115620000f7576000826001600160a01b031682604051620000a4919062000399565b600060405180830381855af49150503d8060008114620000e1576040519150601f19603f3d011682016040523d82523d6000602084013e620000e6565b606091505b5050905080620000f557600080fd5b505b5062000127905060017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61046200035d565b600080516020620009a58339815191521462000147576200014762000383565b6200015f82600080516020620009a583398151915255565b505050620003b7565b6200017e816200020860201b620003a31760201c565b620001f55760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e747261637420616464726573730000000000606482015260840160405180910390fd5b600080516020620009c583398151915255565b6001600160a01b03163b151590565b80516001600160a01b03811681146200022f57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620002675781810151838201526020016200024d565b8381111562000277576000848401525b50505050565b6000806000606084860312156200029357600080fd5b6200029e8462000217565b9250620002ae6020850162000217565b60408501519092506001600160401b0380821115620002cc57600080fd5b818601915086601f830112620002e157600080fd5b815181811115620002f657620002f662000234565b604051601f8201601f19908116603f0116810190838211818310171562000321576200032162000234565b816040528281528960208487010111156200033b57600080fd5b6200034e8360208301602088016200024a565b80955050505050509250925092565b6000828210156200037e57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052600160045260246000fd5b60008251620003ad8184602087016200024a565b9190910192915050565b6105de80620003c76000396000f3fe60806040526004361061004e5760003560e01c80633659cfe6146100655780634f1ef286146100855780635c60da1b146100985780638f283970146100c9578063f851a440146100e95761005d565b3661005d5761005b6100fe565b005b61005b6100fe565b34801561007157600080fd5b5061005b6100803660046104d3565b610130565b61005b6100933660046104f5565b610163565b3480156100a457600080fd5b506100ad610208565b6040516001600160a01b03909116815260200160405180910390f35b3480156100d557600080fd5b5061005b6100e43660046104d3565b610260565b3480156100f557600080fd5b506100ad610368565b61012e6101297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b6103b2565b565b600080516020610589833981519152546001600160a01b0316330361015b57610158816103d6565b50565b6101586100fe565b600080516020610589833981519152546001600160a01b031633036101fb5761018b836103d6565b6000836001600160a01b031683836040516101a7929190610578565b600060405180830381855af49150503d80600081146101e2576040519150601f19603f3d011682016040523d82523d6000602084013e6101e7565b606091505b50509050806101f557600080fd5b50505050565b6102036100fe565b505050565b60006102206000805160206105898339815191525490565b6001600160a01b0316330361025557507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b61025d6100fe565b90565b600080516020610589833981519152546001600160a01b0316330361015b576001600160a01b0381166102f95760405162461bcd60e51b815260206004820152603660248201527f43616e6e6f74206368616e6765207468652061646d696e206f6620612070726f604482015275787920746f20746865207a65726f206164647265737360501b60648201526084015b60405180910390fd5b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6103306000805160206105898339815191525490565b604080516001600160a01b03928316815291841660208301520160405180910390a16101588160008051602061058983398151915255565b60006103806000805160206105898339815191525490565b6001600160a01b0316330361025557506000805160206105898339815191525490565b6001600160a01b03163b151590565b3660008037600080366000845af43d6000803e8080156103d1573d6000f35b3d6000fd5b6103df81610416565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b6001600160a01b0381163b6104935760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000060648201526084016102f0565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55565b80356001600160a01b03811681146104ce57600080fd5b919050565b6000602082840312156104e557600080fd5b6104ee826104b7565b9392505050565b60008060006040848603121561050a57600080fd5b610513846104b7565b9250602084013567ffffffffffffffff8082111561053057600080fd5b818601915086601f83011261054457600080fd5b81358181111561055357600080fd5b87602082850101111561056557600080fd5b6020830194508093505050509250925092565b818382376000910190815291905056feb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103a26469706673582212201247ea1a2ad59100c67468b059feaa48c2c2463619292b34a646025d4a3981f964736f6c634300080d0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc2dd96d0459d7a19d9973c629335d112af970ad4894b70919d288614388ef8eaea26469706673582212209629de71be88e91a76b1847b6a3e6d23a5582715f0408fb91bb4fecae212188064736f6c634300080d0033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620001215760003560e01c80638da5cb5b11620000af578063bc22ff4e116200007a578063bc22ff4e146200025e578063c0a697c91462000275578063ef9bf15a1462000289578063f23fa79414620002a4578063f2fde38b14620002c357600080fd5b80638da5cb5b14620001fe578063a36ab4691462000210578063b70245f21462000227578063b808755e146200024757600080fd5b806364b1f9a111620000f057806364b1f9a114620001ad5780636910dcce14620001c4578063715018a614620001dd57806377881c7b14620001e757600080fd5b8063114c20f014620001265780633da0c131146200014d5780634352aa9f146200017d5780635da43bc91462000196575b600080fd5b6200013a684c505374616b696e6760b81b81565b6040519081526020015b60405180910390f35b620001646200015e36600462001070565b620002da565b6040516001600160a01b03909116815260200162000144565b620001946200018e366004620010ba565b620004f7565b005b62000164620001a736600462001070565b62000546565b62000164620001be366004620010df565b62000732565b6200013a6d2332b2a234b9ba3934b13aba37b960911b81565b6200019462000923565b62000164620001f83660046200112d565b6200095e565b6000546001600160a01b031662000164565b620001646200022136600462001220565b62000b73565b6200013a74464e4654436f6c6c656374696f6e466163746f727960581b81565b6200016462000258366004620010df565b62000d69565b6200013a6b2b30bab63a26b0b730b3b2b960a11b81565b60015462000164906001600160a01b031681565b6200013a6f496e76656e746f72795374616b696e6760801b81565b6200013a7329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b81565b62000194620002d4366004620010ba565b62000f53565b600080546001600160a01b03163314620003115760405162461bcd60e51b815260040162000308906200127d565b60405180910390fd5b6001546001600160a01b03166200033b57604051630d17f6b760e41b815260040160405180910390fd5b600063afccd7c360e01b84846040516024016200035a929190620012b2565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620003a09062001045565b620003ae939291906200131c565b604051809103906000f080158015620003cb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200041157600080fd5b505af115801562000426573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815274464e4654436f6c6c656374696f6e466163746f727960581b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200049057600080fd5b505af1158015620004a5573d6000803e3d6000fd5b5050505074464e4654436f6c6c656374696f6e466163746f727960581b60001b60008051602062001d398339815191528333604051620004e7929190620012b2565b60405180910390a2509392505050565b6000546001600160a01b03163314620005245760405162461bcd60e51b815260040162000308906200127d565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600080546001600160a01b03163314620005745760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b03166200059e57604051630d17f6b760e41b815260040160405180910390fd5b600063f79b61ba60e01b8484604051602401620005bd929190620012b2565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620006039062001045565b62000611939291906200131c565b604051809103906000f0801580156200062e573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200067457600080fd5b505af115801562000689573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b8152684c505374616b696e6760b81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620006e757600080fd5b505af1158015620006fc573d6000803e3d6000fd5b50505050684c505374616b696e6760b81b60001b60008051602062001d398339815191528333604051620004e7929190620012b2565b600080546001600160a01b03163314620007605760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b03166200078a57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b031663399cb35360e11b1790529051849033908390620007df9062001045565b620007ed939291906200131c565b604051809103906000f0801580156200080a573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200085057600080fd5b505af115801562000865573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526b2b30bab63a26b0b730b3b2b960a11b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620008c657600080fd5b505af1158015620008db573d6000803e3d6000fd5b505050506b2b30bab63a26b0b730b3b2b960a11b60001b60008051602062001d39833981519152833360405162000914929190620012b2565b60405180910390a25092915050565b6000546001600160a01b03163314620009505760405162461bcd60e51b815260040162000308906200127d565b6200095c600062000ff5565b565b600080546001600160a01b031633146200098c5760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b0316620009b657604051630d17f6b760e41b815260040160405180910390fd5b6000638a2a1e2f60e01b858585604051602401620009d7939291906200131c565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b038381831617835250505050905085338260405162000a1d9062001045565b62000a2b939291906200131c565b604051809103906000f08015801562000a48573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000a8e57600080fd5b505af115801562000aa3573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81527329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000b0c57600080fd5b505af115801562000b21573d6000803e3d6000fd5b505050507329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60001b60008051602062001d39833981519152833360405162000b62929190620012b2565b60405180910390a250949350505050565b600080546001600160a01b0316331462000ba15760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b031662000bcb57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b0316637aed47c560e01b179052905186903390839062000c309062001045565b62000c3e939291906200131c565b604051809103906000f08015801562000c5b573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000ca157600080fd5b505af115801562000cb6573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526d2332b2a234b9ba3934b13aba37b960911b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000d1957600080fd5b505af115801562000d2e573d6000803e3d6000fd5b505050506d2332b2a234b9ba3934b13aba37b960911b60001b60008051602062001d39833981519152833360405162000b62929190620012b2565b600080546001600160a01b0316331462000d975760405162461bcd60e51b815260040162000308906200127d565b6001546001600160a01b031662000dc157604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b0316636bf4b28d60e01b179052905184903390839062000e169062001045565b62000e24939291906200131c565b604051809103906000f08015801562000e41573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000e8757600080fd5b505af115801562000e9c573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526f496e76656e746f72795374616b696e6760801b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000f0157600080fd5b505af115801562000f16573d6000803e3d6000fd5b505050506f496e76656e746f72795374616b696e6760801b60001b60008051602062001d39833981519152833360405162000914929190620012b2565b6000546001600160a01b0316331462000f805760405162461bcd60e51b815260040162000308906200127d565b6001600160a01b03811662000fe75760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840162000308565b62000ff28162000ff5565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6109e5806200135483390190565b80356001600160a01b03811681146200106b57600080fd5b919050565b6000806000606084860312156200108657600080fd5b620010918462001053565b9250620010a16020850162001053565b9150620010b16040850162001053565b90509250925092565b600060208284031215620010cd57600080fd5b620010d88262001053565b9392505050565b60008060408385031215620010f357600080fd5b620010fe8362001053565b91506200110e6020840162001053565b90509250929050565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156200114457600080fd5b6200114f8562001053565b93506200115f6020860162001053565b92506200116f6040860162001053565b9150606085013567ffffffffffffffff808211156200118d57600080fd5b818701915087601f830112620011a257600080fd5b813581811115620011b757620011b762001117565b604051601f8201601f19908116603f01168101908382118183101715620011e257620011e262001117565b816040528281528a6020848701011115620011fc57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080600080608085870312156200123757600080fd5b620012428562001053565b9350620012526020860162001053565b9250620012626040860162001053565b9150620012726060860162001053565b905092959194509250565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b0392831681529116602082015260400190565b6000815180845260005b81811015620012f457602081850181015186830182015201620012d6565b8181111562001307576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b038481168252831660208201526060604082018190526000906200134a90830184620012cc565b9594505050505056fe6080604052604051620009e5380380620009e583398101604081905262000026916200027d565b82816200005560017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd6200035d565b600080516020620009c58339815191521462000075576200007562000383565b620000808262000168565b805115620000f7576000826001600160a01b031682604051620000a4919062000399565b600060405180830381855af49150503d8060008114620000e1576040519150601f19603f3d011682016040523d82523d6000602084013e620000e6565b606091505b5050905080620000f557600080fd5b505b5062000127905060017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61046200035d565b600080516020620009a58339815191521462000147576200014762000383565b6200015f82600080516020620009a583398151915255565b505050620003b7565b6200017e816200020860201b620003a31760201c565b620001f55760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e747261637420616464726573730000000000606482015260840160405180910390fd5b600080516020620009c583398151915255565b6001600160a01b03163b151590565b80516001600160a01b03811681146200022f57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620002675781810151838201526020016200024d565b8381111562000277576000848401525b50505050565b6000806000606084860312156200029357600080fd5b6200029e8462000217565b9250620002ae6020850162000217565b60408501519092506001600160401b0380821115620002cc57600080fd5b818601915086601f830112620002e157600080fd5b815181811115620002f657620002f662000234565b604051601f8201601f19908116603f0116810190838211818310171562000321576200032162000234565b816040528281528960208487010111156200033b57600080fd5b6200034e8360208301602088016200024a565b80955050505050509250925092565b6000828210156200037e57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052600160045260246000fd5b60008251620003ad8184602087016200024a565b9190910192915050565b6105de80620003c76000396000f3fe60806040526004361061004e5760003560e01c80633659cfe6146100655780634f1ef286146100855780635c60da1b146100985780638f283970146100c9578063f851a440146100e95761005d565b3661005d5761005b6100fe565b005b61005b6100fe565b34801561007157600080fd5b5061005b6100803660046104d3565b610130565b61005b6100933660046104f5565b610163565b3480156100a457600080fd5b506100ad610208565b6040516001600160a01b03909116815260200160405180910390f35b3480156100d557600080fd5b5061005b6100e43660046104d3565b610260565b3480156100f557600080fd5b506100ad610368565b61012e6101297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b6103b2565b565b600080516020610589833981519152546001600160a01b0316330361015b57610158816103d6565b50565b6101586100fe565b600080516020610589833981519152546001600160a01b031633036101fb5761018b836103d6565b6000836001600160a01b031683836040516101a7929190610578565b600060405180830381855af49150503d80600081146101e2576040519150601f19603f3d011682016040523d82523d6000602084013e6101e7565b606091505b50509050806101f557600080fd5b50505050565b6102036100fe565b505050565b60006102206000805160206105898339815191525490565b6001600160a01b0316330361025557507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b61025d6100fe565b90565b600080516020610589833981519152546001600160a01b0316330361015b576001600160a01b0381166102f95760405162461bcd60e51b815260206004820152603660248201527f43616e6e6f74206368616e6765207468652061646d696e206f6620612070726f604482015275787920746f20746865207a65726f206164647265737360501b60648201526084015b60405180910390fd5b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6103306000805160206105898339815191525490565b604080516001600160a01b03928316815291841660208301520160405180910390a16101588160008051602061058983398151915255565b60006103806000805160206105898339815191525490565b6001600160a01b0316330361025557506000805160206105898339815191525490565b6001600160a01b03163b151590565b3660008037600080366000845af43d6000803e8080156103d1573d6000f35b3d6000fd5b6103df81610416565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b6001600160a01b0381163b6104935760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000060648201526084016102f0565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55565b80356001600160a01b03811681146104ce57600080fd5b919050565b6000602082840312156104e557600080fd5b6104ee826104b7565b9392505050565b60008060006040848603121561050a57600080fd5b610513846104b7565b9250602084013567ffffffffffffffff8082111561053057600080fd5b818601915086601f83011261054457600080fd5b81358181111561055357600080fd5b87602082850101111561056557600080fd5b6020830194508093505050509250925092565b818382376000910190815291905056feb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103a26469706673582212201247ea1a2ad59100c67468b059feaa48c2c2463619292b34a646025d4a3981f964736f6c634300080d0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc2dd96d0459d7a19d9973c629335d112af970ad4894b70919d288614388ef8eaea26469706673582212209629de71be88e91a76b1847b6a3e6d23a5582715f0408fb91bb4fecae212188064736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "deployFNFTCollectionFactory(address,address,address)": {
        "params": {
          "_logic": "the implementation",
          "_vaultManager": "variable needed for FNFTCollectionFactory"
        }
      },
      "deployFNFTStaking(address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployFeeDistributor(address,address,address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployLPStaking(address,address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployStakingTokenProvider(address,address,address,string)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployVaultManager(address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deployFNFTCollectionFactory(address,address,address)": {
        "notice": "the function to deploy FNFTCollectionFactory"
      },
      "deployFNFTStaking(address,address)": {
        "notice": "the function to deploy FNFTStaking"
      },
      "deployFeeDistributor(address,address,address,address)": {
        "notice": "the function to deploy FeeDistributor"
      },
      "deployLPStaking(address,address,address)": {
        "notice": "the function to deploy LPStaking"
      },
      "deployStakingTokenProvider(address,address,address,string)": {
        "notice": "the function to deploy StakingTokenProvider"
      },
      "deployVaultManager(address,address)": {
        "notice": "the function to deploy FNFTCollectionFactory"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2934,
        "contract": "src/contracts/proxy/Deployer.sol:Deployer",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 18681,
        "contract": "src/contracts/proxy/Deployer.sol:Deployer",
        "label": "proxyController",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IMultiProxyController)19207"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IMultiProxyController)19207": {
        "encoding": "inplace",
        "label": "contract IMultiProxyController",
        "numberOfBytes": "20"
      }
    }
  }
}